Files Content
=============

SCANNING: /home/ayes/water-quality-monitor/frontend/components
================================================================================

Directory: /home/ayes/water-quality-monitor/frontend/components

--- FILE: /home/ayes/water-quality-monitor/frontend/components/MetricsChart.tsx ---
import React from 'react';
import { Line } from 'react-chartjs-2';

// Define the Reading type
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  latitude?: number;
  longitude?: number;
  txHash?: string;
  
  // Water Quality
  turbidity?: number;
  pH?: number;
  temperature?: number;
  conductivity?: number;
  tds?: number;
  dissolvedOxygen?: number;
  chlorineResidual?: number;
  orp?: number;
  nitrates?: number;
  phosphates?: number;
  ammonia?: number;
  hardness?: number;
  
  // Flow & Hydraulic
  flowRate?: number;
  pressure?: number;
  velocity?: number;
  cumulativeVolume?: number;
  
  // Tank
  tankLevel?: number;
  waterDepth?: number;
  currentVolume?: number;
  
  // Pump
  pumpStatus?: boolean;
  runtime?: number;
  startStopCount?: number;
  motorCurrent?: number;
  motorVoltage?: number;
  vibration?: number;
  bearingTemperature?: number;
  energyConsumption?: number;
  
  // Valve
  valvePosition?: number;
  
  // Network & Environmental
  signalStrength?: number;
  uptime?: number;
  batteryLevel?: number;
  rainfall?: number;
  ambientTemperature?: number;
  humidity?: number;
  soilMoisture?: number;
  
  // Garbage
  fillLevel?: number;
  doorOpen?: boolean;
};

type MetricsChartProps = {
  selectedSensor: string | null;
  readings: Record<string, Reading[]>;
  activeMetricTab: string;
  setActiveMetricTab: (tab: string) => void;
};

// Helper function to generate CSV data from readings
const generateCSV = (
  readings: Reading[], 
  sensorType: string, 
  includePrimary: boolean = true, 
  includeSecondary: boolean = true
): string => {
  if (!readings || readings.length === 0) return '';
  
  // Determine which fields to include based on sensor type and tab selections
  let headers: string[] = ['Timestamp'];
  let rows: string[][] = [];
  
  // Add date in ISO format for each reading
  readings.forEach(reading => {
    const row: string[] = [new Date(reading.timestamp).toISOString()];
    rows.push(row);
  });
  
  // Add metrics based on sensor type and which tabs to include
  if (sensorType === 'water-quality') {
    if (includePrimary) {
      headers.push('Turbidity (NTU)', 'pH', 'Temperature (°C)', 'Conductivity (μS/cm)');
      readings.forEach((reading, idx) => {
        rows[idx].push(
          String(reading.turbidity ?? ''),
          String(reading.pH ?? ''),
          String(reading.temperature ?? ''),
          String(reading.conductivity ?? '')
        );
      });
    }
    
    if (includeSecondary) {
      headers.push('Chlorine (mg/L)', 'TDS (mg/L)', 'Dissolved Oxygen (mg/L)', 'ORP (mV)');
      readings.forEach((reading, idx) => {
        rows[idx].push(
          String(reading.chlorineResidual ?? ''),
          String(reading.tds ?? ''),
          String(reading.dissolvedOxygen ?? ''),
          String(reading.orp ?? '')
        );
      });
    }
  } else if (sensorType === 'pump') {
    if (includePrimary) {
      headers.push('Flow Rate (L/min)', 'Pressure (bar)', 'Vibration (mm/s)');
      readings.forEach((reading, idx) => {
        rows[idx].push(
          String(reading.flowRate ?? ''),
          String(reading.pressure ?? ''),
          String(reading.vibration ?? '')
        );
      });
    }
    
    if (includeSecondary) {
      headers.push('Motor Current (A)', 'Energy (kWh)', 'Bearing Temp (°C)');
      readings.forEach((reading, idx) => {
        rows[idx].push(
          String(reading.motorCurrent ?? ''),
          String(reading.energyConsumption ?? ''),
          String(reading.bearingTemperature ?? '')
        );
      });
    }
  } else if (sensorType === 'tank') {
    if (includePrimary) {
      headers.push('Tank Level (%)', 'Volume (m³)', 'Temperature (°C)');
      readings.forEach((reading, idx) => {
        rows[idx].push(
          String(reading.tankLevel ?? ''),
          String(reading.currentVolume ?? ''),
          String(reading.temperature ?? '')
        );
      });
    }
    
    if (includeSecondary) {
      headers.push('Water Depth (m)', 'Time to Empty (hours)');
      
      // Calculate time to empty for each row
      readings.forEach((reading, idx) => {
        let timeToEmpty = '';
        if (idx >= 2) {
          const levelChange = (reading.tankLevel || 0) - (readings[idx-2].tankLevel || 0);
          const timeChange = (reading.timestamp - readings[idx-2].timestamp) / 1000 / 60;
          const rate = levelChange / timeChange;
          if (rate < 0 && reading.tankLevel) {
            timeToEmpty = String(-(reading.tankLevel / rate) / 60);
          }
        }
        
        rows[idx].push(
          String(reading.waterDepth ?? ''),
          timeToEmpty
        );
      });
    }
  } else if (sensorType === 'valve') {
    headers.push('Valve Position (%)', 'Flow Rate (L/min)', 'Pressure (bar)');
    readings.forEach((reading, idx) => {
      rows[idx].push(
        String(reading.valvePosition ?? ''),
        String(reading.flowRate ?? ''),
        String(reading.pressure ?? '')
      );
    });
  } else if (sensorType === 'environmental') {
    headers.push('Rainfall (mm)', 'Temperature (°C)', 'Humidity (%)');
    readings.forEach((reading, idx) => {
      rows[idx].push(
        String(reading.rainfall ?? ''),
        String(reading.ambientTemperature ?? ''),
        String(reading.humidity ?? '')
      );
    });
  } else if (sensorType === 'garbage') {
    if (includePrimary) {
      headers.push('Fill Level (%)', 'Door Open', 'Battery Level (%)');
    }
    
    rows = readings.map(reading => {
      const row: string[] = [new Date(reading.timestamp).toISOString()];
      
      if (includePrimary) {
        row.push(
          reading.fillLevel?.toString() || '',
          reading.doorOpen ? '1' : '0',
          reading.batteryLevel?.toString() || ''
        );
      }
      
      return row;
    });
  }
  
  // Create CSV content
  const csvContent = [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n');
  
  return csvContent;
};

const MetricsChart: React.FC<MetricsChartProps> = ({ 
  selectedSensor, 
  readings, 
  activeMetricTab, 
  setActiveMetricTab 
}) => {
  // Memoize the sensor type to prevent unnecessary recalculations on refresh
  const getSensorType = React.useCallback((sensorId: string): string => {
    if (!sensorId || !readings[sensorId] || readings[sensorId].length === 0) return 'unknown';
    return readings[sensorId][0].sensorType || 'unknown';
  }, [readings]);

  // Export metrics data to CSV
  const handleExportCSV = React.useCallback(() => {
    if (!selectedSensor || !readings[selectedSensor] || readings[selectedSensor].length === 0) {
      console.error('No data available to export');
      return;
    }
    
    const sensorReadings = readings[selectedSensor];
    const sensorType = getSensorType(selectedSensor);
    const sensorName = selectedSensor || 'sensor';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${sensorName}-metrics-${timestamp}.csv`;
    
    // Determine if we need both primary and secondary metrics
    const hasPrimaryAndSecondary = 
      sensorType !== 'valve' && 
      sensorType !== 'environmental' &&
      sensorType !== 'garbage';
    
    // Generate CSV with appropriate metrics
    const csvContent = generateCSV(
      sensorReadings,
      sensorType,
      true, // Always include primary
      hasPrimaryAndSecondary // Include secondary only if applicable
    );
    
    // Create a blob and download link
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [selectedSensor, readings, getSensorType]);

  // When tab is changed, update parent state and localStorage
  const handleTabChange = React.useCallback((tab: string) => {
    if (selectedSensor) {
      const type = getSensorType(selectedSensor);
      
      // Skip changes for valve and environmental sensors
      if (type === 'valve' || type === 'environmental') {
        return; // These sensors only support the primary tab
      }
    }
    
    // For all other cases, update in this order:
    console.log('Tab changed to:', tab);
    
    // 1. Update the local ref
    lastValidTabRef.current = tab;
    
    // 2. Update localStorage
    localStorage.setItem('activeMetricTab', tab);
    
    // 3. Update parent state
    setActiveMetricTab(tab);
  }, [setActiveMetricTab, selectedSensor, getSensorType]);
  
  // Keep track of the last valid tab state to prevent unwanted resets
  const lastValidTabRef = React.useRef(activeMetricTab);
  
  // Combined effect to handle tab state on mount and sensor type changes
  React.useEffect(() => {
    // Update the ref with the current active tab
    lastValidTabRef.current = activeMetricTab;
    
    if (selectedSensor) {
      const type = getSensorType(selectedSensor);
      
      // For valve and environmental sensors, always use primary
      if ((type === 'valve' || type === 'environmental')) {
        if (activeMetricTab !== 'primary') {
          console.log('Forcing primary tab for valve/environmental sensor');
          handleTabChange('primary');
        }
      } else {
        // For other sensor types, update localStorage with current tab
        localStorage.setItem('activeMetricTab', activeMetricTab);
      }
    }
  }, [selectedSensor, activeMetricTab, getSensorType, handleTabChange]);
  
  // Determine which tab should be active based on sensor type and last valid tab
  const getEffectiveTab = React.useCallback(() => {
    if (selectedSensor) {
      const type = getSensorType(selectedSensor);
      // For valve and environmental sensors, always use primary data
      if (type === 'valve' || type === 'environmental') {
        return 'primary';
      }
    }
    // Use the lastValidTabRef for non-special sensor types
    return lastValidTabRef.current || activeMetricTab;
  }, [selectedSensor, activeMetricTab, getSensorType]);
  
  // Prepare chart data for the selected sensor
  const getChartData = () => {
    if (!selectedSensor || !readings[selectedSensor]) {
      return {
        labels: [],
        datasets: [
          {
            label: 'No Data',
            data: [],
            borderColor: '#007BFF',
            backgroundColor: 'rgba(0, 123, 255, 0.2)',
          },
        ],
      };
    }

    const sensorReadings = readings[selectedSensor];
    const sensorType = getSensorType(selectedSensor);
    const labels = sensorReadings.map(r => new Date(r.timestamp).toLocaleTimeString());
    
    // Different datasets based on sensor type and active tab
    if (sensorType === 'water-quality') {
      if (getEffectiveTab() === 'primary') {
        return {
          labels,
          datasets: [
            {
              label: 'Turbidity (NTU)',
              data: sensorReadings.map(r => r.turbidity),
              borderColor: '#007BFF',
              backgroundColor: 'rgba(0, 123, 255, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'pH',
              data: sensorReadings.map(r => r.pH),
              borderColor: '#28A745',
              backgroundColor: 'rgba(40, 167, 69, 0.2)',
              yAxisID: 'pH',
            },
            {
              label: 'Temperature (°C)',
              data: sensorReadings.map(r => r.temperature),
              borderColor: '#DC3545',
              backgroundColor: 'rgba(220, 53, 69, 0.2)',
              yAxisID: 'temp',
            },
            {
              label: 'Conductivity (μS/cm)',
              data: sensorReadings.map(r => r.conductivity),
              borderColor: '#FFC107',
              backgroundColor: 'rgba(255, 193, 7, 0.2)',
              yAxisID: 'conductivity',
            },
          ],
        };
      } else {
        return {
          labels,
          datasets: [
            {
              label: 'Chlorine (mg/L)',
              data: sensorReadings.map(r => r.chlorineResidual),
              borderColor: '#6610f2',
              backgroundColor: 'rgba(102, 16, 242, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'TDS (mg/L)',
              data: sensorReadings.map(r => r.tds),
              borderColor: '#fd7e14',
              backgroundColor: 'rgba(253, 126, 20, 0.2)',
              yAxisID: 'tds',
            },
            {
              label: 'Dissolved Oxygen (mg/L)',
              data: sensorReadings.map(r => r.dissolvedOxygen),
              borderColor: '#20c997',
              backgroundColor: 'rgba(32, 201, 151, 0.2)',
              yAxisID: 'do',
            },
            {
              label: 'ORP (mV)',
              data: sensorReadings.map(r => r.orp),
              borderColor: '#17a2b8',
              backgroundColor: 'rgba(23, 162, 184, 0.2)',
              yAxisID: 'orp',
            },
          ],
        };
      }
    } else if (sensorType === 'pump') {
      if (getEffectiveTab() === 'primary') {
        return {
          labels,
          datasets: [
            {
              label: 'Flow Rate (L/min)',
              data: sensorReadings.map(r => r.flowRate),
              borderColor: '#007BFF',
              backgroundColor: 'rgba(0, 123, 255, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'Pressure (bar)',
              data: sensorReadings.map(r => r.pressure),
              borderColor: '#28A745',
              backgroundColor: 'rgba(40, 167, 69, 0.2)',
              yAxisID: 'pressure',
            },
            {
              label: 'Vibration (mm/s)',
              data: sensorReadings.map(r => r.vibration),
              borderColor: '#DC3545',
              backgroundColor: 'rgba(220, 53, 69, 0.2)',
              yAxisID: 'vibration',
            },
          ],
        };
      } else {
        return {
          labels,
          datasets: [
            {
              label: 'Motor Current (A)',
              data: sensorReadings.map(r => r.motorCurrent),
              borderColor: '#6f42c1',
              backgroundColor: 'rgba(111, 66, 193, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'Energy (kWh)',
              data: sensorReadings.map(r => r.energyConsumption),
              borderColor: '#fd7e14',
              backgroundColor: 'rgba(253, 126, 20, 0.2)',
              yAxisID: 'energy',
            },
            {
              label: 'Bearing Temp (°C)',
              data: sensorReadings.map(r => r.bearingTemperature),
              borderColor: '#dc3545',
              backgroundColor: 'rgba(220, 53, 69, 0.2)',
              yAxisID: 'temp',
            },
          ],
        };
      }
    } else if (sensorType === 'tank') {
      if (getEffectiveTab() === 'primary') {
        return {
          labels,
          datasets: [
            {
              label: 'Tank Level (%)',
              data: sensorReadings.map(r => r.tankLevel),
              borderColor: '#007BFF',
              backgroundColor: 'rgba(0, 123, 255, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'Volume (m³)',
              data: sensorReadings.map(r => r.currentVolume),
              borderColor: '#17a2b8',
              backgroundColor: 'rgba(23, 162, 184, 0.2)',
              yAxisID: 'volume',
            },
            {
              label: 'Temperature (°C)',
              data: sensorReadings.map(r => r.temperature),
              borderColor: '#DC3545',
              backgroundColor: 'rgba(220, 53, 69, 0.2)',
              yAxisID: 'temp',
            },
          ],
        };
      } else {
        // For tanks, we'll show inflow/outflow prediction metrics
        const waterDepthData = sensorReadings.map(r => r.waterDepth);
        
        // Simplified time to empty calculation
        const timeToEmpty = sensorReadings.map((r, i, arr) => {
          if (i < 2) return null;
          const levelChange = (r.tankLevel || 0) - (arr[i-2].tankLevel || 0);
          const timeChange = (r.timestamp - arr[i-2].timestamp) / 1000 / 60;
          const rate = levelChange / timeChange;
          if (rate < 0 && r.tankLevel) {
            return -(r.tankLevel / rate) / 60;
          }
          return null;
        });
        
        return {
          labels,
          datasets: [
            {
              label: 'Water Depth (m)',
              data: waterDepthData,
              borderColor: '#17a2b8',
              backgroundColor: 'rgba(23, 162, 184, 0.2)',
              yAxisID: 'y',
            },
            {
              label: 'Time to Empty (hours)',
              data: timeToEmpty,
              borderColor: '#dc3545',
              backgroundColor: 'rgba(220, 53, 69, 0.2)',
              yAxisID: 'time',
            },
          ],
        };
      }
    } else if (sensorType === 'valve') {
      return {
        labels,
        datasets: [
          {
            label: 'Valve Position (%)',
            data: sensorReadings.map(r => r.valvePosition),
            borderColor: '#007BFF',
            backgroundColor: 'rgba(0, 123, 255, 0.2)',
            yAxisID: 'y',
          },
          {
            label: 'Flow Rate (L/min)',
            data: sensorReadings.map(r => r.flowRate),
            borderColor: '#28A745',
            backgroundColor: 'rgba(40, 167, 69, 0.2)',
            yAxisID: 'flow',
          },
          {
            label: 'Pressure (bar)',
            data: sensorReadings.map(r => r.pressure),
            borderColor: '#DC3545',
            backgroundColor: 'rgba(220, 53, 69, 0.2)',
            yAxisID: 'pressure',
          },
        ],
      };
    } else if (sensorType === 'environmental') {
      return {
        labels,
        datasets: [
          {
            label: 'Rainfall (mm)',
            data: sensorReadings.map(r => r.rainfall),
            borderColor: '#007BFF',
            backgroundColor: 'rgba(0, 123, 255, 0.2)',
            yAxisID: 'y',
          },
          {
            label: 'Temperature (°C)',
            data: sensorReadings.map(r => r.ambientTemperature),
            borderColor: '#DC3545',
            backgroundColor: 'rgba(220, 53, 69, 0.2)',
            yAxisID: 'temp',
          },
          {
            label: 'Humidity (%)',
            data: sensorReadings.map(r => r.humidity),
            borderColor: '#6c757d',
            backgroundColor: 'rgba(108, 117, 125, 0.2)',
            yAxisID: 'humidity',
          },
        ],
      };
    } else if (sensorType === 'garbage') {
      if (activeMetricTab === 'primary') {
        return {
          labels,
          datasets: [
            {
              label: 'Fill Level (%)',
              data: sensorReadings.map(r => r.fillLevel || null),
              borderColor: 'rgba(40, 167, 69, 1)',
              backgroundColor: 'rgba(40, 167, 69, 0.2)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              yAxisID: 'y'
            },
            {
              label: 'Battery Level (%)',
              data: sensorReadings.map(r => r.batteryLevel || null),
              borderColor: 'rgba(108, 117, 125, 1)',
              backgroundColor: 'rgba(108, 117, 125, 0.1)',
              borderWidth: 1,
              tension: 0.4,
              borderDash: [5, 5],
              fill: false,
              yAxisID: 'y'
            }
          ]
        };
      } else {
        return {
          labels,
          datasets: [
            {
              label: 'Door Open Events',
              data: sensorReadings.map(r => r.doorOpen ? 1 : 0),
              borderColor: 'rgba(255, 193, 7, 1)',
              backgroundColor: 'rgba(255, 193, 7, 0.2)',
              borderWidth: 2,
              tension: 0,
              fill: true,
              yAxisID: 'y',
              pointRadius: sensorReadings.map(r => r.doorOpen ? 4 : 0),
              pointBackgroundColor: 'rgba(255, 193, 7, 1)',
              stepped: 'before' as 'before'
            }
          ]
        };
      }
    } else {
      // Default fallback
      return {
        labels,
        datasets: [
          {
            label: 'Primary Value',
            data: sensorReadings.map(r => 
              r.turbidity ?? r.flowRate ?? r.tankLevel ?? r.valvePosition ?? 0
            ),
            borderColor: '#007BFF',
            backgroundColor: 'rgba(0, 123, 255, 0.2)',
          },
        ],
      };
    }
  };
  
  // Get chart options based on sensor type
  const getChartOptions = () => {
    const baseOptions = {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 0 // Disable animation for better performance with frequent updates
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
          },
          ticks: {
            color: 'rgba(255, 255, 255, 0.8)',
          },
        },
        x: {
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
          },
          ticks: {
            color: 'rgba(255, 255, 255, 0.8)',
          },
        },
      },
      plugins: {
        legend: {
          labels: {
            color: 'rgba(255, 255, 255, 0.8)',
          },
        },
      },
    };
    
    if (!selectedSensor) return baseOptions;
    
    const sensorType = getSensorType(selectedSensor);
    
    if (sensorType === 'water-quality') {
      if (getEffectiveTab() === 'primary') {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Turbidity (NTU)',
                color: 'rgba(255, 255, 255, 0.8)',
              },
              max: 100,
            },
            pH: {
              position: 'right',
              title: {
                display: true,
                text: 'pH',
                color: 'rgba(40, 167, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 5,
              max: 9,
              ticks: {
                color: 'rgba(40, 167, 69, 0.8)',
              },
            },
            temp: {
              position: 'right',
              title: {
                display: true,
                text: 'Temperature (°C)',
                color: 'rgba(220, 53, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 30,
              ticks: {
                color: 'rgba(220, 53, 69, 0.8)',
              },
            },
            conductivity: {
              position: 'right',
              title: {
                display: true,
                text: 'Conductivity (μS/cm)',
                color: 'rgba(255, 193, 7, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 1000,
              ticks: {
                color: 'rgba(255, 193, 7, 0.8)',
              },
            },
          },
        };
      } else {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Chlorine (mg/L)',
                color: 'rgba(102, 16, 242, 0.8)',
              },
              min: 0,
              max: 2,
            },
            tds: {
              position: 'right',
              title: {
                display: true,
                text: 'TDS (mg/L)',
                color: 'rgba(253, 126, 20, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 1000,
              ticks: {
                color: 'rgba(253, 126, 20, 0.8)',
              },
            },
            do: {
              position: 'right',
              title: {
                display: true,
                text: 'Dissolved Oxygen (mg/L)',
                color: 'rgba(32, 201, 151, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 14,
              ticks: {
                color: 'rgba(32, 201, 151, 0.8)',
              },
            },
            orp: {
              position: 'right',
              title: {
                display: true,
                text: 'ORP (mV)',
                color: 'rgba(23, 162, 184, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 500,
              ticks: {
                color: 'rgba(23, 162, 184, 0.8)',
              },
            },
          },
        };
      }
    } else if (sensorType === 'pump') {
      if (getEffectiveTab() === 'primary') {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Flow Rate (L/min)',
                color: 'rgba(255, 255, 255, 0.8)',
              },
              max: 600,
            },
            pressure: {
              position: 'right',
              title: {
                display: true,
                text: 'Pressure (bar)',
                color: 'rgba(40, 167, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 6,
              ticks: {
                color: 'rgba(40, 167, 69, 0.8)',
              },
            },
            vibration: {
              position: 'right',
              title: {
                display: true,
                text: 'Vibration (mm/s)',
                color: 'rgba(220, 53, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 0.2,
              ticks: {
                color: 'rgba(220, 53, 69, 0.8)',
              },
            },
          },
        };
      } else {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Motor Current (A)',
                color: 'rgba(111, 66, 193, 0.8)',
              },
              min: 0,
              max: 20,
            },
            energy: {
              position: 'right',
              title: {
                display: true,
                text: 'Energy (kWh)',
                color: 'rgba(253, 126, 20, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 200,
              ticks: {
                color: 'rgba(253, 126, 20, 0.8)',
              },
            },
            temp: {
              position: 'right',
              title: {
                display: true,
                text: 'Bearing Temp (°C)',
                color: 'rgba(220, 53, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 20,
              max: 70,
              ticks: {
                color: 'rgba(220, 53, 69, 0.8)',
              },
            },
          },
        };
      }
    } else if (sensorType === 'tank') {
      if (getEffectiveTab() === 'primary') {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Tank Level (%)',
                color: 'rgba(255, 255, 255, 0.8)',
              },
              min: 0,
              max: 100,
            },
            volume: {
              position: 'right',
              title: {
                display: true,
                text: 'Volume (m³)',
                color: 'rgba(23, 162, 184, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 1600,
              ticks: {
                color: 'rgba(23, 162, 184, 0.8)',
              },
            },
            temp: {
              position: 'right',
              title: {
                display: true,
                text: 'Temperature (°C)',
                color: 'rgba(220, 53, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 30,
              ticks: {
                color: 'rgba(220, 53, 69, 0.8)',
              },
            },
          },
        };
      } else {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Water Depth (m)',
                color: 'rgba(23, 162, 184, 0.8)',
              },
              min: 0,
              max: 6,
            },
            time: {
              position: 'right',
              title: {
                display: true,
                text: 'Time to Empty (hours)',
                color: 'rgba(220, 53, 69, 0.8)',
              },
              grid: {
                display: false,
              },
              min: 0,
              max: 72,
              ticks: {
                color: 'rgba(220, 53, 69, 0.8)',
              },
            },
          },
        };
      }
    } else if (sensorType === 'valve') {
      return {
        ...baseOptions,
        scales: {
          ...baseOptions.scales,
          y: {
            ...baseOptions.scales.y,
            position: 'left',
            title: {
              display: true,
              text: 'Valve Position (%)',
              color: 'rgba(255, 255, 255, 0.8)',
            },
            min: 0,
            max: 100,
          },
          flow: {
            position: 'right',
            title: {
              display: true,
              text: 'Flow Rate (L/min)',
              color: 'rgba(40, 167, 69, 0.8)',
            },
            grid: {
              display: false,
            },
            min: 0,
            max: 600,
            ticks: {
              color: 'rgba(40, 167, 69, 0.8)',
            },
          },
          pressure: {
            position: 'right',
            title: {
              display: true,
              text: 'Pressure (bar)',
              color: 'rgba(220, 53, 69, 0.8)',
            },
            grid: {
              display: false,
            },
            min: 0,
            max: 6,
            ticks: {
              color: 'rgba(220, 53, 69, 0.8)',
            },
          },
        },
      };
    } else if (sensorType === 'environmental') {
      return {
        ...baseOptions,
        scales: {
          ...baseOptions.scales,
          y: {
            ...baseOptions.scales.y,
            position: 'left',
            title: {
              display: true,
              text: 'Rainfall (mm)',
              color: 'rgba(0, 123, 255, 0.8)',
            },
            min: 0,
            max: 25,
          },
          temp: {
            position: 'right',
            title: {
              display: true,
              text: 'Temperature (°C)',
              color: 'rgba(220, 53, 69, 0.8)',
            },
            grid: {
              display: false,
            },
            min: 0,
            max: 40,
            ticks: {
              color: 'rgba(220, 53, 69, 0.8)',
            },
          },
          humidity: {
            position: 'right',
            title: {
              display: true,
              text: 'Humidity (%)',
              color: 'rgba(108, 117, 125, 0.8)',
            },
            grid: {
              display: false,
            },
            min: 0,
            max: 100,
            ticks: {
              color: 'rgba(108, 117, 125, 0.8)',
            },
          },
        },
      };
    } else if (sensorType === 'garbage') {
      if (activeMetricTab === 'primary') {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Fill Level (%)',
                color: 'rgba(255, 255, 255, 0.8)',
              },
              min: 0,
              max: 100,
            }
          }
        };
      } else {
        return {
          ...baseOptions,
          scales: {
            ...baseOptions.scales,
            y: {
              ...baseOptions.scales.y,
              position: 'left',
              title: {
                display: true,
                text: 'Door Status',
                color: 'rgba(255, 255, 255, 0.8)',
              },
              min: 0,
              max: 1,
              ticks: {
                ...baseOptions.scales.y.ticks,
                stepSize: 1,
                callback: function(value) {
                  return value === 0 ? 'Closed' : 'Open';
                }
              }
            }
          }
        };
      }
    } else {
      // Default fallback
      return baseOptions;
    }
  };

  return (
    <div className="h-full flex flex-col">
      <div className="flex justify-between items-center mb-3">
        <h2 className="text-lg font-semibold">Metrics</h2>
        {selectedSensor && (
          <div className="flex gap-2 items-center">
            {/* Only show tabs for sensor types that have secondary metrics */}
            {getSensorType(selectedSensor) !== 'valve' && getSensorType(selectedSensor) !== 'environmental' && (
              <div className="flex p-1 bg-slate-800/60 rounded-lg">
                <button 
                  className={`px-3 py-1 rounded-md text-sm font-medium transition-colors ${
                    activeMetricTab === 'primary' 
                      ? 'bg-indigo-600 text-white' 
                      : 'text-slate-300 hover:text-white'
                  }`}
                  onClick={() => handleTabChange('primary')}
                >
                  Primary
                </button>
                <button 
                  className={`px-3 py-1 rounded-md text-sm font-medium transition-colors ${
                    activeMetricTab === 'secondary' 
                      ? 'bg-indigo-600 text-white' 
                      : 'text-slate-300 hover:text-white'
                  }`}
                  onClick={() => handleTabChange('secondary')}
                >
                  Secondary
                </button>
              </div>
            )}
            
            {/* Export button */}
            <button
              className="flex items-center gap-1 px-3 py-1 rounded-md text-sm font-medium text-white bg-emerald-600 hover:bg-emerald-500 transition-colors"
              onClick={handleExportCSV}
              title="Export to CSV"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
              CSV
            </button>
          </div>
        )}
      </div>
      <div className="flex-1">
        {selectedSensor ? (
          <Line data={getChartData()} options={getChartOptions() as any} />
        ) : (
          <div className="flex items-center justify-center h-full text-slate-400">
            Select a sensor to view metrics
          </div>
        )}
      </div>
    </div>
  );
};

export default MetricsChart; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/Timeline.tsx ---
import React from 'react';

type BlockchainEvent = {
  sensorId: string;
  value: number;
  timestamp: number;
  txHash: string;
  metricType?: string;
};

type TimelineProps = {
  events: BlockchainEvent[];
};

const Timeline: React.FC<TimelineProps> = ({ events }) => {
  if (events.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-40 text-gray-300">
        <p>No blockchain events yet</p>
        <p className="text-sm mt-2">Events will appear here when readings are recorded on-chain</p>
      </div>
    );
  }

  // Helper to get metric type name
  const getMetricName = (event: BlockchainEvent): string => {
    if (event.metricType) {
      // Handle garbage-specific event types
      switch (event.metricType) {
        case 'fillLevelAlert': return 'Fill Level Alert';
        case 'collectionConfirmed': return 'Collection Confirmed';
        case 'doorOpenAlert': return 'Door Open Alert';
        case 'batteryLow': return 'Battery Low';
        default: return event.metricType;
      }
    }
    
    // Determine based on sensorId
    if (event.sensorId.includes('wq-sensor')) {
      return 'Turbidity';
    } else if (event.sensorId.includes('pump')) {
      return 'Flow Rate';
    } else if (event.sensorId.includes('tank')) {
      return 'Tank Level';
    } else if (event.sensorId.includes('valve')) {
      return 'Valve Position';
    } else if (event.sensorId.includes('env')) {
      return 'Rainfall';
    } else if (event.sensorId.includes('bin')) {
      return 'Fill Level';
    }
    
    return 'Measurement';
  };
  
  // Helper to get units
  const getMetricUnit = (event: BlockchainEvent): string => {
    const metricName = getMetricName(event);
    
    switch (metricName) {
      case 'Turbidity': return 'NTU';
      case 'Flow Rate': return 'L/min';
      case 'Tank Level': return '%';
      case 'Valve Position': return '% open';
      case 'Rainfall': return 'mm';
      case 'Fill Level':
      case 'Fill Level Alert': return '%';
      case 'Collection Confirmed': return '';
      case 'Door Open Alert': return '';
      case 'Battery Low': return '%';
      default: return '';
    }
  };
  
  // Helper to get color class for the measurement
  const getValueColorClass = (event: BlockchainEvent): string => {
    const metricName = getMetricName(event);
    const value = event.value;
    
    // Handle garbage-specific metric colors
    if (metricName === 'Fill Level Alert' || metricName === 'Fill Level') {
      if (value > 90) return 'text-red-400';
      if (value > 70) return 'text-yellow-400';
      return 'text-green-400';
    }
    
    if (metricName === 'Door Open Alert') return 'text-yellow-400';
    if (metricName === 'Collection Confirmed') return 'text-green-400';
    if (metricName === 'Battery Low') return 'text-red-400';
    
    // Handle water system metrics
    if (metricName === 'Turbidity' && value > 70) return 'text-red-400';
    if (metricName === 'Turbidity' && value > 40) return 'text-yellow-400';
    if (metricName === 'Tank Level' && value < 30) return 'text-red-400';
    
    return 'text-green-400';
  };

  // Helper to format event value based on metric type
  const formatEventValue = (event: BlockchainEvent): string => {
    const metricName = getMetricName(event);
    
    if (metricName === 'Collection Confirmed') {
      return 'Collection completed';
    }
    
    if (metricName === 'Door Open Alert') {
      return 'Door opened';
    }
    
    return `${event.value.toFixed(1)} ${getMetricUnit(event)}`;
  };

  return (
    <div className="overflow-y-auto h-full">
      <div className="space-y-4">
        {events.map((event, index) => (
          <div 
            key={`${event.txHash}-${index}`}
            className="relative pl-6 border-l border-blue-500/50"
          >
            {/* Timeline dot */}
            <div className="absolute left-0 top-0 -translate-x-1/2 w-3 h-3 rounded-full bg-blue-500"></div>
            
            {/* Event content */}
            <div className="mb-2">
              <h4 className="text-white text-sm font-medium">
                Reading from {event.sensorId}
              </h4>
              <p className="text-gray-300 text-xs">
                {new Date(event.timestamp).toLocaleString()}
              </p>
              <p className="text-white text-sm mt-1">
                {getMetricName(event)}: <span className={`font-medium ${getValueColorClass(event)}`}>
                  {formatEventValue(event)}
                </span>
              </p>
              <a
                href={`https://etherscan.io/tx/${event.txHash}`}
                target="_blank"
                rel="noopener noreferrer"
                className="text-xs text-blue-400 hover:underline mt-1 inline-block"
              >
                View on Etherscan ↗
              </a>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Timeline;


================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/GlassCard.js ---
import React from 'react';

const GlassCard = ({ children, className = '' }) => {
  return (
    <div 
      className={`
        rounded-xl 
        p-6 
        shadow-lg 
        backdrop-blur-xl 
        border 
        border-solid 
        border-glassBorder 
        bg-glassBg 
        ${className}
      `}
    >
      {children}
    </div>
  );
};

export default GlassCard;


================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/SensorMap.tsx ---
import React, { useState, useMemo, useEffect, useRef } from 'react';
import 'leaflet/dist/leaflet.css';
import { SENSOR_IDS, PANAMA_CITY_SENSORS, PANAMA_CITY_CENTER, NETWORK_CONNECTIONS } from '../utils/dummyData';
// Dynamically import garbage-related data using require to avoid issues
// with server-side rendering
let GARBAGE_BINS: any[] = [];
let BIN_NETWORK_CONNECTIONS: any[] = [];
if (typeof window !== 'undefined') {
  try {
    const garbageData = require('../utils/garbageDummyData');
    GARBAGE_BINS = garbageData.GARBAGE_BINS;
    BIN_NETWORK_CONNECTIONS = garbageData.BIN_NETWORK_CONNECTIONS;
  } catch (e) {
    console.warn('Failed to load garbage data:', e);
  }
}
import L from 'leaflet';

// Enhanced Reading type with all possible metrics
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  latitude?: number;
  longitude?: number;
  txHash?: string;
  
  // Water Quality
  turbidity?: number;
  pH?: number;
  temperature?: number;
  conductivity?: number;
  tds?: number;
  dissolvedOxygen?: number;
  chlorineResidual?: number;
  orp?: number;
  nitrates?: number;
  phosphates?: number;
  ammonia?: number;
  hardness?: number;
  
  // Flow & Hydraulic
  flowRate?: number;
  pressure?: number;
  velocity?: number;
  cumulativeVolume?: number;
  
  // Tank
  tankLevel?: number;
  waterDepth?: number;
  currentVolume?: number;
  
  // Pump
  pumpStatus?: boolean;
  runtime?: number;
  startStopCount?: number;
  motorCurrent?: number;
  motorVoltage?: number;
  vibration?: number;
  bearingTemperature?: number;
  energyConsumption?: number;
  
  // Valve
  valvePosition?: number;
  
  // Network & Environmental
  signalStrength?: number;
  uptime?: number;
  batteryLevel?: number;
  rainfall?: number;
  ambientTemperature?: number;
  humidity?: number;
  soilMoisture?: number;
  
  // Garbage
  fillLevel?: number;
  doorOpen?: boolean;
  lastCollectionTimestamp?: number;
  binType?: string;
};

type SensorMapProps = {
  sensors: string[];
  readings: Record<string, Reading[]>;
  selectedSensor: string | null;
  onSensorSelect: (sensorId: string) => void;
};

// Enhanced map with different sensor types and visualizations
const SensorMap: React.FC<SensorMapProps> = ({ 
  sensors, 
  readings, 
  selectedSensor, 
  onSensorSelect 
}) => {
  const [mapMode, setMapMode] = useState<string>('all');
  const mapRef = useRef<HTMLDivElement>(null);
  const leafletMap = useRef<any>(null);
  const markersLayer = useRef<any>(null);
  
  // Generate network connections dynamically
  const generateNetworkConnections = () => {
    // Check if we're dealing with garbage bins
    if (sensors.length > 0 && sensors[0].startsWith('bin-')) {
      try {
        // For garbage bins, use the bin connections
        return BIN_NETWORK_CONNECTIONS;
      } catch (e) {
        console.error('Error loading bin connections:', e);
        return [];
      }
    }
    
    // Otherwise, use water system connections
    // Start with base connections from dummyData.js
    const baseConnections = [...NETWORK_CONNECTIONS];
    
    // Add connections for additional dynamic sensors
    const waterQualitySensors = PANAMA_CITY_SENSORS.filter(s => s.type === 'water-quality');
    const pumpSensors = PANAMA_CITY_SENSORS.filter(s => s.type === 'pump');
    const tankSensors = PANAMA_CITY_SENSORS.filter(s => s.type === 'tank');
    const valveSensors = PANAMA_CITY_SENSORS.filter(s => s.type === 'valve');
    
    // Add connections in a more organic way - each water quality sensor should connect to the nearest pump or valve
    waterQualitySensors.forEach(wq => {
      if (!baseConnections.some(conn => conn.from === wq.id || conn.to === wq.id)) {
        // Find closest pump or valve
        let closestSensor = null;
        let minDistance = Infinity;
        
        const potentialTargets = [...pumpSensors, ...valveSensors];
        potentialTargets.forEach(target => {
          const distance = Math.sqrt(
            Math.pow(wq.lat - target.lat, 2) + 
            Math.pow(wq.lng - target.lng, 2)
          );
          
          if (distance < minDistance && distance < 0.02) { // Only connect if within ~2km
            minDistance = distance;
            closestSensor = target;
          }
        });
        
        if (closestSensor) {
          baseConnections.push({ from: wq.id, to: closestSensor.id });
        }
      }
    });
    
    // Connect pumps to nearest tanks if not already connected
    pumpSensors.forEach(pump => {
      if (!baseConnections.some(conn => conn.from === pump.id && tankSensors.some(t => t.id === conn.to))) {
        // Find closest tank
        let closestTank = null;
        let minDistance = Infinity;
        
        tankSensors.forEach(tank => {
          const distance = Math.sqrt(
            Math.pow(pump.lat - tank.lat, 2) + 
            Math.pow(pump.lng - tank.lng, 2)
          );
          
          if (distance < minDistance && distance < 0.03) { // Only connect if within ~3km
            minDistance = distance;
            closestTank = tank;
          }
        });
        
        if (closestTank) {
          baseConnections.push({ from: pump.id, to: closestTank.id });
        }
      }
    });
    
    return baseConnections;
  };

  // Network connections between sensors
  const networkConnections = useMemo(() => generateNetworkConnections(), []);

  // Reference to the network lines layer
  const linesLayer = useRef<any>(null);

  // Draw network connections
  const drawConnections = () => {
    if (!leafletMap.current || !linesLayer.current) return;
    
    // Clear existing lines
    linesLayer.current.clearLayers();
    
    import('leaflet').then((L) => {
      // Only show connections between sensors that match the current filter
      networkConnections.forEach(connection => {
        // Get locations for both sensors
        const fromSensor = findSensorById(connection.from);
        const toSensor = findSensorById(connection.to);
        
        // Skip if either sensor is not found
        if (!fromSensor || !toSensor) return;
        
        // Skip if either sensor doesn't match the current filter
        if (mapMode !== 'all') {
          const fromType = fromSensor.type;
          const toType = toSensor.type;
          if (fromType !== mapMode && toType !== mapMode) return;
        }
        
        // Get readings to determine flow status
        const fromReading = getLatestReading(connection.from);
        const toReading = getLatestReading(connection.to);
        
        // Flow is active if:
        // - From is a pump that's running OR a valve that's open
        // - OR destination is a storage tank
        let flowActive = false;
        let flowColor = '#0066AA';
        let dashArray = null;
        
        if (fromSensor.type === 'pump' && fromReading?.pumpStatus) {
          flowActive = true;
        } else if (fromSensor.type === 'valve' && fromReading?.valvePosition && fromReading.valvePosition > 20) {
          flowActive = true;
        } else if (toSensor.type === 'tank') {
          flowActive = true;
          dashArray = '5, 5';
        }
        
        // Change color based on water quality if flowing from a water quality sensor
        if (flowActive && fromSensor.type === 'water-quality') {
          flowColor = getWaterQualityColor(fromReading);
        }
        
        // Draw line if flow is active
        if (flowActive) {
          // Create polyline between the two points
          const line = L.polyline(
            [[fromSensor.lat, fromSensor.lng], [toSensor.lat, toSensor.lng]],
            { 
              color: flowColor,
              weight: 3,
              opacity: 0.7,
              dashArray: dashArray
            }
          ).addTo(linesLayer.current);
        }
      });
    });
  };
  
  // Initialize map
  useEffect(() => {
    if (typeof window !== 'undefined' && mapRef.current && !leafletMap.current) {
      // Dynamically import Leaflet to avoid SSR issues
      import('leaflet').then((L) => {
        // Determine if we're showing garbage bins
        const isGarbageDashboard = sensors.length > 0 && sensors[0].startsWith('bin-');
        
        // Create map instance with a darker style suitable for a water network
        leafletMap.current = L.map(mapRef.current).setView([PANAMA_CITY_CENTER.lat, PANAMA_CITY_CENTER.lng], 13);
        
        // Add a dark-themed map tile layer - CartoDB Dark Matter
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
          subdomains: 'abcd',
          maxZoom: 19
        }).addTo(leafletMap.current);
        
        // Create layer groups
        linesLayer.current = L.layerGroup().addTo(leafletMap.current);
        markersLayer.current = L.layerGroup().addTo(leafletMap.current);
        
        // Initial update
        drawConnections();
        updateMarkers();
      });
    }
    
    // Cleanup on unmount
    return () => {
      if (leafletMap.current) {
        leafletMap.current.remove();
        leafletMap.current = null;
      }
    };
  }, []);

  // Redraw connections when map mode changes
  useEffect(() => {
    drawConnections();
  }, [mapMode]);
  
  // Get the latest reading for each sensor
  const getLatestReading = (sensorId: string): Reading | null => {
    const sensorReadings = readings[sensorId];
    if (!sensorReadings || sensorReadings.length === 0) {
      return null;
    }
    return sensorReadings[sensorReadings.length - 1];
  };

  // Cache sensor types to make the component less sensitive to reading updates
  const sensorTypes = useMemo(() => {
    const types: Record<string, string> = {};
    sensors.forEach(sensorId => {
      const reading = getLatestReading(sensorId);
      types[sensorId] = reading?.sensorType || 'unknown';
    });
    return types;
  }, [sensors, readings]); // Include readings for initial type detection, but not for position updates

  // Get sensor type from the cached map
  const getSensorType = (sensorId: string): string => {
    return sensorTypes[sensorId] || 'unknown';
  };

  // Determine the color based on water quality parameters
  const getWaterQualityColor = (reading: Reading | null): string => {
    if (!reading) return '#888888'; // Gray for no data
    
    // Prioritize critical parameters
    if (reading.pH && (reading.pH < 6.5 || reading.pH > 8.5)) return '#DC3545'; // Red for bad pH
    if (reading.turbidity && reading.turbidity > 60) return '#DC3545'; // Red for high turbidity
    if (reading.chlorineResidual && reading.chlorineResidual < 0.2) return '#DC3545'; // Red for low chlorine
    
    // Check for warning thresholds
    if (reading.pH && (reading.pH < 6.8 || reading.pH > 8.0)) return '#FFC107'; // Yellow for borderline pH
    if (reading.turbidity && reading.turbidity > 30) return '#FFC107'; // Yellow for moderate turbidity
    if (reading.tds && reading.tds > 500) return '#FFC107'; // Yellow for high TDS
    
    return '#28A745'; // Green for good parameters
  };

  // Determine color for pump status
  const getPumpColor = (reading: Reading | null): string => {
    if (!reading) return '#888888'; // Gray for no data
    
    if (reading.pumpStatus === true) {
      // Running pump - check for issues
      if (reading.vibration && reading.vibration > 0.15) return '#DC3545'; // Red for high vibration
      if (reading.bearingTemperature && reading.bearingTemperature > 55) return '#DC3545'; // Red for high temp
      return '#28A745'; // Green for healthy running pump
    } else {
      return '#6c757d'; // Dark gray for stopped pump
    }
  };

  // Determine color for tank level
  const getTankLevelColor = (reading: Reading | null): string => {
    if (!reading || reading.tankLevel === undefined) return '#888888'; // Gray for no data
    
    const level = reading.tankLevel;
    if (level < 20) return '#DC3545'; // Red for low level
    if (level < 40) return '#FFC107'; // Yellow for medium-low level
    return '#28A745'; // Green for good level
  };

  // Determine color for valve status
  const getValveColor = (reading: Reading | null): string => {
    if (!reading || reading.valvePosition === undefined) return '#888888'; // Gray for no data
    
    // For valves, we use blue when open and gray when closed
    const position = reading.valvePosition;
    if (position < 5) return '#6c757d'; // Almost closed
    if (position > 90) return '#007BFF'; // Almost fully open
    return '#17a2b8'; // Partially open
  };

  // Get fill level color for garbage bins
  const getFillLevelColor = (reading: Reading | null): string => {
    if (!reading || reading.fillLevel === undefined) return '#cccccc';
    
    // Based on garbage bin fill level
    if (reading.fillLevel > 90) return '#DC3545'; // Red - nearly full
    if (reading.fillLevel > 70) return '#FFC107'; // Yellow - medium fill level
    return '#28A745'; // Green - low fill level
  };

  // Get primary metric to display based on sensor type
  const getPrimaryMetric = (reading: Reading | null): { value: string, label: string } => {
    if (!reading) return { value: 'N/A', label: '' };
    
    switch (reading.sensorType) {
      case 'water-quality':
        return { 
          value: reading.turbidity?.toFixed(1) || 'N/A', 
          label: 'NTU' 
        };
      case 'pump':
        return { 
          value: reading.pumpStatus ? 'ON' : 'OFF',
          label: reading.flowRate ? `${reading.flowRate.toFixed(0)} L/m` : ''
        };
      case 'tank':
        return { 
          value: reading.tankLevel?.toFixed(0) || 'N/A',
          label: '%'
        };
      case 'valve':
        return { 
          value: reading.valvePosition?.toFixed(0) || 'N/A',
          label: '% open'
        };
      case 'environmental':
        return { 
          value: reading.rainfall?.toFixed(1) || 'N/A',
          label: 'mm'
        };
      case 'garbage':
        // For garbage bins, show fill level
        return { 
          value: reading.fillLevel?.toFixed(0) || 'N/A', 
          label: '%' 
        };
      default:
        return { value: 'N/A', label: '' };
    }
  };

  // Get the appropriate icon based on sensor type
  const getSensorIcon = (sensorType: string, reading: Reading | null, sensorId: string): JSX.Element => {
    const isSelected = sensorId === selectedSensor;
    
    switch (sensorType) {
      case 'water-quality':
        return (
          <circle
            r={isSelected ? 12 : 8}
            fill={getWaterQualityColor(reading)}
            stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
            strokeWidth={isSelected ? 3 : 1}
          />
        );
      case 'pump':
        return (
          <g>
            <rect
              x={isSelected ? -14 : -10}
              y={isSelected ? -14 : -10}
              width={isSelected ? 28 : 20}
              height={isSelected ? 28 : 20}
              rx="4"
              fill={getPumpColor(reading)}
              stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
              strokeWidth={isSelected ? 3 : 1}
            />
            {/* Simple pump icon */}
            <path
              d={isSelected ? 
                "M-7,-3 L-7,3 L0,3 L0,7 L7,0 L0,-7 L0,-3 Z" : 
                "M-5,-2 L-5,2 L0,2 L0,5 L5,0 L0,-5 L0,-2 Z"}
              fill="white"
            />
          </g>
        );
      case 'tank':
        const tankLevel = reading?.tankLevel || 0;
        const tankHeight = isSelected ? 24 : 18;
        const tankWidth = isSelected ? 20 : 16;
        const tankX = isSelected ? -10 : -8;
        const tankY = isSelected ? -12 : -9;
        const fillHeight = (tankLevel / 100) * tankHeight;
        const fillY = tankY + tankHeight - fillHeight;
        
        return (
          <g>
            {/* Tank outline */}
            <rect
              x={tankX}
              y={tankY}
              width={tankWidth}
              height={tankHeight}
              rx="2"
              fill="none"
              stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
              strokeWidth={isSelected ? 3 : 1}
            />
            {/* Tank fill level */}
            <rect
              x={tankX}
              y={fillY}
              width={tankWidth}
              height={fillHeight}
              rx="2"
              fill={getTankLevelColor(reading)}
            />
          </g>
        );
      case 'valve':
        return (
          <g>
            <polygon
              points={isSelected ? "-12,0 0,-12 12,0 0,12" : "-9,0 0,-9 9,0 0,9"}
              fill={getValveColor(reading)}
              stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
              strokeWidth={isSelected ? 3 : 1}
            />
            {/* Valve position indicator */}
            {reading?.valvePosition !== undefined && (
              <line
                x1="0"
                y1="0"
                x2={Math.cos((reading.valvePosition / 100) * Math.PI) * (isSelected ? 8 : 6)}
                y2={Math.sin((reading.valvePosition / 100) * Math.PI) * (isSelected ? 8 : 6)}
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
              />
            )}
          </g>
        );
      case 'environmental':
        return (
          <g>
            <polygon
              points={isSelected ? "0,-12 -10,6 10,6" : "0,-9 -8,4 8,4"}
              fill="#17a2b8"
              stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
              strokeWidth={isSelected ? 3 : 1}
            />
            {/* Raindrops */}
            <path
              d={isSelected ? 
                "M-4,0 Q-4,3 -2,3 Q0,3 0,0 Q0,-3 -2,-3 Q-4,-3 -4,0 M4,0 Q4,3 6,3 Q8,3 8,0 Q8,-3 6,-3 Q4,-3 4,0" : 
                "M-3,0 Q-3,2 -1.5,2 Q0,2 0,0 Q0,-2 -1.5,-2 Q-3,-2 -3,0 M3,0 Q3,2 4.5,2 Q6,2 6,0 Q6,-2 4.5,-2 Q3,-2 3,0"}
              fill="#007BFF"
            />
          </g>
        );
      case 'garbage':
        // For garbage bins, we'll create a bin icon with fill level
        const binFillLevel = reading?.fillLevel || 0;
        const binHeight = isSelected ? 24 : 18;
        const binWidth = isSelected ? 20 : 16;
        const binX = isSelected ? -10 : -8;
        const binY = isSelected ? -12 : -9;
        const binFillHeight = (binFillLevel / 100) * binHeight;
        const binFillY = binY + binHeight - binFillHeight;
        const doorOpen = reading?.doorOpen || false;
        
        return (
          <g>
            {/* Bin body outline */}
            <rect
              x={binX}
              y={binY}
              width={binWidth}
              height={binHeight}
              rx="2"
              fill="none"
              stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
              strokeWidth={isSelected ? 3 : 1}
            />
            {/* Bin fill level */}
            <rect
              x={binX}
              y={binFillY}
              width={binWidth}
              height={binFillHeight}
              rx="2"
              fill={getFillLevelColor(reading)}
            />
            {/* Bin lid - show angled if door is open */}
            <rect
              x={binX - 2}
              y={binY - 3}
              width={binWidth + 4}
              height={2}
              fill="white"
              transform={doorOpen ? `rotate(30, ${binX + binWidth/2}, ${binY - 2})` : ''}
            />
          </g>
        );
      default:
        return (
          <circle
            r={isSelected ? 12 : 8}
            fill="#888888"
            stroke={isSelected ? 'white' : 'rgba(255,255,255,0.5)'}
            strokeWidth={isSelected ? 3 : 1}
          />
        );
    }
  };

  // Calculate display positions for sensors - memoized with stable dependencies
  const calculateSensorPositions = useMemo(() => {
    const positions: Record<string, { x: number; y: number }> = {};
    
    // Organize by sensor types
    const sensorsByType: Record<string, string[]> = {};
    
    sensors.forEach(sensorId => {
      const type = getSensorType(sensorId);
      if (!sensorsByType[type]) {
        sensorsByType[type] = [];
      }
      sensorsByType[type].push(sensorId);
    });
    
    // Basic layout grid - simplfied for fixed positions
    const grid = {
      'water-quality': { startX: 100, startY: 80, spacingX: 80, spacingY: 60, cols: 3 },
      'pump': { startX: 150, startY: 160, spacingX: 100, spacingY: 50, cols: 2 },
      'tank': { startX: 100, startY: 230, spacingX: 80, spacingY: 60, cols: 2 },
      'valve': { startX: 250, startY: 220, spacingX: 70, spacingY: 50, cols: 2 },
      'environmental': { startX: 320, startY: 80, spacingX: 60, spacingY: 50, cols: 1 },
      'unknown': { startX: 200, startY: 150, spacingX: 50, spacingY: 50, cols: 2 }
    };
    
    // Position each sensor based on type - using a more stable approach
    Object.entries(sensorsByType).forEach(([type, sensorIds]) => {
      const layout = grid[type] || grid['unknown'];
      
      sensorIds.forEach((sensorId, index) => {
        const col = index % layout.cols;
        const row = Math.floor(index / layout.cols);
        
        // Use simple grid layout for demo purposes - more reliable than trying
        // to convert lat/lng for this demo
        const x = layout.startX + (col * layout.spacingX);
        const y = layout.startY + (row * layout.spacingY);
        
        positions[sensorId] = { x, y };
      });
    });
    
    return positions;
  }, [sensors, getSensorType]); // Only recalculate when sensors array or types change

  // Update markers on map based on current state
  const updateMarkers = () => {
    if (!markersLayer.current || !leafletMap.current) return;

    // Clear existing markers
    markersLayer.current.clearLayers();

    // Apply current filter
    const sensorsToDisplay = mapMode === 'all' 
      ? sensors 
      : sensors.filter(sensorId => getSensorType(sensorId) === mapMode);

    // Find each sensor in our Panama City locations array or use lat/lng from readings
    import('leaflet').then((L) => {
      sensorsToDisplay.forEach(sensorId => {
        // Try to find sensor in our predefined locations
        let sensorLocation = findSensorById(sensorId);
        const reading = getLatestReading(sensorId);
        const sensorType = getSensorType(sensorId);
        
        // If not found in our predefined locations, check if the reading has coordinates
        if (!sensorLocation && reading && reading.latitude && reading.longitude) {
          sensorLocation = {
            id: sensorId,
            name: sensorId.split('-').join(' ').toUpperCase(),
            lat: reading.latitude,
            lng: reading.longitude,
            type: sensorType
          };
        }
        
        // If we have coordinates for this sensor from either source
        if (sensorLocation) {
          // Create custom icon
          const isSelected = sensorId === selectedSensor;
          let color = '#888888'; // Default gray
          
          // Determine color based on sensor type and reading status
          switch (sensorType) {
            case 'water-quality':
              color = getWaterQualityColor(reading);
              break;
            case 'pump':
              color = getPumpColor(reading);
              break;
            case 'tank':
              color = getTankLevelColor(reading);
              break;
            case 'valve':
              color = getValveColor(reading);
              break;
            case 'environmental':
              color = '#17a2b8'; // Teal for environmental sensors
              break;
            case 'garbage':
              color = getFillLevelColor(reading);
              break;
          }
          
          // Create an icon with associated CSS classes
          const iconHtml = `<div class="sensor-icon ${sensorType}-icon" style="background-color: ${color}; width: ${isSelected ? '20px' : '14px'}; height: ${isSelected ? '20px' : '14px'}; border-radius: ${sensorType === 'water-quality' ? '50%' : '3px'}; border: ${isSelected ? '3px' : '1px'} solid white;"></div>`;
          
          const sensorIcon = L.divIcon({
            html: iconHtml,
            className: `sensor-marker ${isSelected ? 'selected' : ''}`,
            iconSize: [isSelected ? 24 : 16, isSelected ? 24 : 16],
            iconAnchor: [isSelected ? 12 : 8, isSelected ? 12 : 8]
          });
          
          // Create marker and add click handler
          const marker = L.marker([sensorLocation.lat, sensorLocation.lng], { 
            icon: sensorIcon,
            zIndexOffset: isSelected ? 1000 : 0
          }).addTo(markersLayer.current);
          
          // Add popup with sensor information
          const primaryMetric = getPrimaryMetric(reading);
          marker.bindTooltip(`
            <div class="sensor-tooltip">
              <div class="sensor-name">${sensorLocation.name}</div>
              <div class="sensor-id">${sensorId}</div>
              <div class="sensor-reading">${primaryMetric.value} ${primaryMetric.label}</div>
            </div>
          `);
          
          // Add click handler
          marker.on('click', () => {
            onSensorSelect(sensorId);
          });
        }
      });
    });
  };
  
  // Filter sensors based on current map mode
  const filteredSensors = useMemo(() => {
    return mapMode === 'all' 
      ? sensors 
      : sensors.filter(sensorId => getSensorType(sensorId) === mapMode);
  }, [sensors, mapMode, sensorTypes]); // Add sensorTypes as dependency instead of recalculating

  // Update markers when filtered sensors change
  useEffect(() => {
    updateMarkers();
  }, [filteredSensors, selectedSensor]);

  // Now calculateSensorPositions is the actual positions, not a function
  const sensorPositions = calculateSensorPositions;

  // Helper to find a sensor by ID
  const findSensorById = (sensorId: string) => {
    // Check if this is a garbage bin ID
    if (sensorId.startsWith('bin-')) {
      // Dynamically import and use GARBAGE_BINS
      return GARBAGE_BINS.find(s => s.id === sensorId);
    }
    
    // Otherwise use water system sensors
    return PANAMA_CITY_SENSORS.find(s => s.id === sensorId);
  };

  // Get sensor coordinates if available from our Panama City dataset
  const getSensorCoordinates = (sensorId: string) => {
    const sensor = findSensorById(sensorId);
    if (sensor) {
      return { lat: sensor.lat, lng: sensor.lng };
    }
    return null;
  };
  
  // Focus the map on a specific sensor
  const focusOnSensor = (sensorId: string) => {
    if (!leafletMap.current) return;
    const sensor = findSensorById(sensorId);
    if (!sensor) return;

    const currentZoom = leafletMap.current.getZoom();
    leafletMap.current.setView(
      [sensor.lat, sensor.lng],
      currentZoom,            // ← reuse whatever zoom you're already at
      { animate: true }       // optional, for smooth animation
    );
  };
  
  /* Alternative implementation using panTo (Option B)
  const focusOnSensor = (sensorId: string) => {
    if (!leafletMap.current) return;
    const sensor = findSensorById(sensorId);
    if (!sensor) return;

    leafletMap.current.panTo(
      [sensor.lat, sensor.lng],
      { animate: true }       // optional, for smooth animation
    );
  };
  */
  
  // When selected sensor changes, focus the map on it
  useEffect(() => {
    if (selectedSensor) {
      focusOnSensor(selectedSensor);
    }
  }, [selectedSensor]);
  
  // Create stable filtered sensor positions for legacy SVG rendering
  // (kept for backwards compatibility but not actively used)
  const filteredSensorPositions = useMemo(() => {
    return Object.fromEntries(
      filteredSensors.map(sensorId => [
        sensorId, 
        sensorPositions[sensorId] || { x: 200, y: 150 }
      ])
    );
  }, [filteredSensors, sensorPositions]);

  // Render with Leaflet map
  return (
    <div className="w-full h-full bg-white/5 rounded-lg overflow-hidden flex flex-col relative">
      {/* Layer control buttons */}
      <div className="flex flex-wrap gap-1 mb-2 px-2 py-2 bg-slate-800 z-10">
        <button 
          className={`text-xs px-2 py-1 rounded ${mapMode === 'all' ? 'bg-blue-500 text-white' : 'bg-white/10 text-white/70'}`}
          onClick={() => {
            setMapMode('all');
          }}
        >
          All
        </button>
        <button 
          className={`text-xs px-2 py-1 rounded ${mapMode === 'garbage' ? 'bg-green-500 text-white' : 'bg-white/10 text-white/70'}`}
          onClick={() => {
            setMapMode('garbage');
          }}
        >
          Garbage
        </button>
      </div>
      
      {/* Debug overlay */}
      {sensors.length === 0 && (
        <div className="absolute top-10 left-0 right-0 text-center text-white bg-red-500/50 p-2 z-20">
          No sensors available
        </div>
      )}
      
      {/* Map legend */}
      <div className="absolute bottom-4 right-4 bg-slate-800/80 p-3 rounded-lg z-10 text-white text-xs">
        <div className="font-bold mb-1">Sensor Types</div>
        <div className="flex items-center gap-1 mb-1">
          <div className="w-3 h-3 rounded bg-green-500"></div>
          <span>Garbage Bin</span>
        </div>
      </div>
      
      {/* The actual map container */}
      <div 
        ref={mapRef} 
        className="flex-grow w-full relative"
        style={{ minHeight: "calc(100% - 40px)" }}
      />
      
      {/* Custom CSS for map markers - added inline for demonstration */}
      <style jsx global>{`
        .sensor-marker {
          display: flex;
          justify-content: center;
          align-items: center;
        }
        
        .sensor-icon {
          border-radius: 50%;
          box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        .water-quality-icon {
          border-radius: 50%;
        }
        
        .pump-icon {
          border-radius: 3px;
        }
        
        .tank-icon {
          border-radius: 3px;
        }
        
        .valve-icon {
          transform: rotate(45deg);
        }
        
        .environmental-icon {
          border-radius: 0;
          clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }
        
        .selected {
          z-index: 1000;
        }
        
        .sensor-tooltip {
          padding: 5px;
        }
        
        .sensor-name {
          font-weight: bold;
          margin-bottom: 3px;
        }
        
        .sensor-id {
          font-size: 0.8em;
          opacity: 0.8;
          margin-bottom: 3px;
        }
        
        .sensor-reading {
          font-weight: bold;
        }
      `}</style>
    </div>
  );
};

export default SensorMap;


================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/SensorDetails.tsx ---
import React from 'react';

// Define the Reading type
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  latitude?: number;
  longitude?: number;
  txHash?: string;
  
  // Water Quality
  turbidity?: number;
  pH?: number;
  temperature?: number;
  conductivity?: number;
  tds?: number;
  dissolvedOxygen?: number;
  chlorineResidual?: number;
  orp?: number;
  nitrates?: number;
  phosphates?: number;
  ammonia?: number;
  hardness?: number;
  
  // Flow & Hydraulic
  flowRate?: number;
  pressure?: number;
  velocity?: number;
  cumulativeVolume?: number;
  
  // Tank
  tankLevel?: number;
  waterDepth?: number;
  currentVolume?: number;
  
  // Pump
  pumpStatus?: boolean;
  runtime?: number;
  startStopCount?: number;
  motorCurrent?: number;
  motorVoltage?: number;
  vibration?: number;
  bearingTemperature?: number;
  energyConsumption?: number;
  
  // Valve
  valvePosition?: number;
  
  // Network & Environmental
  signalStrength?: number;
  uptime?: number;
  batteryLevel?: number;
  rainfall?: number;
  ambientTemperature?: number;
  humidity?: number;
  soilMoisture?: number;
  
  // Garbage
  fillLevel?: number;
  doorOpen?: boolean;
  lastCollectionTimestamp?: number;
  binType?: string;
};

type SensorDetailsProps = {
  selectedSensor: string | null;
  sensors: string[];
  readings: Record<string, Reading[]>;
  onSensorSelect: (sensorId: string) => void;
};

const SensorDetails: React.FC<SensorDetailsProps> = ({
  selectedSensor,
  sensors,
  readings,
  onSensorSelect
}) => {
  // Memoize the sensor type to prevent unnecessary recalculations on refresh
  const getSensorType = React.useCallback((sensorId: string): string => {
    if (!sensorId || !readings[sensorId] || readings[sensorId].length === 0) return 'unknown';
    return readings[sensorId][0].sensorType || 'unknown';
  }, [readings]);
  
  // Get the latest reading for the selected sensor
  const getLatestReading = (): Reading | null => {
    if (!selectedSensor || !readings[selectedSensor] || readings[selectedSensor].length === 0) {
      return null;
    }
    return readings[selectedSensor][readings[selectedSensor].length - 1];
  };

  // Get human-readable sensor type label
  const getSensorTypeLabel = (sensorType: string): string => {
    switch (sensorType) {
      case 'water-quality': return 'Water Quality Sensor';
      case 'pump': return 'Pump Station';
      case 'tank': return 'Storage Tank';
      case 'valve': return 'Control Valve';
      case 'environmental': return 'Environment Monitor';
      case 'garbage': return 'Garbage Bin Sensor';
      default: return 'Unknown Sensor';
    }
  };

  // Format date function for collection timestamp
  const formatDate = (timestamp: number): string => {
    return new Date(timestamp).toLocaleString();
  };

  // Dynamic sensor status info based on type and readings
  const getSensorStatusInfo = () => {
    if (!selectedSensor) return null;
    
    const latestReading = getLatestReading();
    if (!latestReading) return null;
    
    const sensorType = getSensorType(selectedSensor);
    
    switch (sensorType) {
      case 'water-quality':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">pH</div>
              <div className="text-2xl font-semibold">
                {latestReading.pH?.toFixed(1) || 'N/A'}
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Turbidity</div>
              <div className="text-2xl font-semibold">
                {latestReading.turbidity?.toFixed(1) || 'N/A'} <span className="text-sm">NTU</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Temperature</div>
              <div className="text-2xl font-semibold">
                {latestReading.temperature?.toFixed(1) || 'N/A'} <span className="text-sm">°C</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">TDS</div>
              <div className="text-2xl font-semibold">
                {latestReading.tds?.toFixed(0) || 'N/A'} <span className="text-sm">mg/L</span>
              </div>
            </div>
          </div>
        );
      case 'pump':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Status</div>
              <div className="text-2xl font-semibold">
                {latestReading.pumpStatus ? 
                  <span className="text-green-500">Running</span> : 
                  <span className="text-gray-500">Stopped</span>}
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Flow Rate</div>
              <div className="text-2xl font-semibold">
                {latestReading.flowRate?.toFixed(0) || 'N/A'} <span className="text-sm">L/min</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Pressure</div>
              <div className="text-2xl font-semibold">
                {latestReading.pressure?.toFixed(1) || 'N/A'} <span className="text-sm">bar</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Vibration</div>
              <div className="text-2xl font-semibold">
                {latestReading.vibration?.toFixed(2) || 'N/A'} <span className="text-sm">mm/s</span>
              </div>
            </div>
          </div>
        );
      case 'tank':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Level</div>
              <div className="text-2xl font-semibold">
                {latestReading.tankLevel?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Volume</div>
              <div className="text-2xl font-semibold">
                {latestReading.currentVolume?.toFixed(0) || 'N/A'} <span className="text-sm">m³</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Water Depth</div>
              <div className="text-2xl font-semibold">
                {latestReading.waterDepth?.toFixed(1) || 'N/A'} <span className="text-sm">m</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Temperature</div>
              <div className="text-2xl font-semibold">
                {latestReading.temperature?.toFixed(1) || 'N/A'} <span className="text-sm">°C</span>
              </div>
            </div>
          </div>
        );
      case 'valve':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Position</div>
              <div className="text-2xl font-semibold">
                {latestReading.valvePosition?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Flow Rate</div>
              <div className="text-2xl font-semibold">
                {latestReading.flowRate?.toFixed(0) || 'N/A'} <span className="text-sm">L/min</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Pressure</div>
              <div className="text-2xl font-semibold">
                {latestReading.pressure?.toFixed(1) || 'N/A'} <span className="text-sm">bar</span>
              </div>
            </div>
          </div>
        );
      case 'environmental':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Rainfall</div>
              <div className="text-2xl font-semibold">
                {latestReading.rainfall?.toFixed(1) || 'N/A'} <span className="text-sm">mm</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Temperature</div>
              <div className="text-2xl font-semibold">
                {latestReading.ambientTemperature?.toFixed(1) || 'N/A'} <span className="text-sm">°C</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Humidity</div>
              <div className="text-2xl font-semibold">
                {latestReading.humidity?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Battery</div>
              <div className="text-2xl font-semibold">
                {latestReading.batteryLevel?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
          </div>
        );
      case 'garbage':
        return (
          <div className="grid grid-cols-2 gap-4 mt-4">
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Fill Level</div>
              <div className="text-2xl font-semibold">
                {latestReading.fillLevel?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Door Status</div>
              <div className="text-2xl font-semibold">
                {latestReading.doorOpen ? 
                  <span className="text-yellow-500">Open</span> : 
                  <span className="text-green-500">Closed</span>}
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Last Collection</div>
              <div className="text-lg font-semibold">
                {latestReading.lastCollectionTimestamp ? 
                  formatDate(latestReading.lastCollectionTimestamp) : 
                  'Not recorded'}
              </div>
            </div>
            <div className="space-y-2">
              <div className="text-gray-400 text-sm">Battery</div>
              <div className="text-2xl font-semibold">
                {latestReading.batteryLevel?.toFixed(0) || 'N/A'} <span className="text-sm">%</span>
              </div>
            </div>
            <div className="col-span-2 space-y-2">
              <div className="text-gray-400 text-sm">Bin Type</div>
              <div className="text-lg font-semibold capitalize">
                {latestReading.binType?.replace('-', ' ') || 'General Waste'}
              </div>
            </div>
          </div>
        );
      default:
        return (
          <div className="mt-4 text-center text-gray-400">
            Sensor details not available
          </div>
        );
    }
  };

  return (
    <div className="h-full flex flex-col">
      <h2 className="text-lg font-semibold mb-3">Sensor Details</h2>
      <div className="flex-1 overflow-y-auto">
        {selectedSensor ? (
          <>
            <div className="flex justify-between items-start">
              <div>
                <h3 className="text-xl font-medium">
                  {selectedSensor}
                </h3>
                <p className="text-slate-400 text-sm">
                  {getSensorTypeLabel(getSensorType(selectedSensor))}
                </p>
              </div>
              <div className="px-2 py-1 rounded-full bg-green-900/30 text-green-400 text-xs">
                Online
              </div>
            </div>
            {getSensorStatusInfo()}
          </>
        ) : (
          <div className="text-center py-8 text-slate-400 h-full flex items-center justify-center">
            Select a sensor to view details
          </div>
        )}
      </div>
    </div>
  );
};

export default SensorDetails; 

================================================================================

Directory: /home/ayes/water-quality-monitor/frontend/components/garbage

--- FILE: /home/ayes/water-quality-monitor/frontend/components/garbage/PointsDashboard.tsx ---
import React, { useState, useEffect } from 'react';
import { USERS, BLOCKCHAIN_EVENTS } from '../../utils/garbageDummyData';
import GlassCard from '../GlassCard';

type User = {
  id: string;
  name: string;
  address: string;
  walletAddress: string;
  pointsBalance: number;
  finesBalance: number;
  onboardedAt: number;
};

type BlockchainEvent = {
  id: string;
  timestamp: number;
  txHash: string;
  eventType: string;
  userId?: string;
  bagId?: string;
  sensorId?: string;
  amount?: number;
  correct?: boolean;
  pointsAwarded?: number;
  fineAmount?: number;
};

const PointsDashboard: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [events, setEvents] = useState<BlockchainEvent[]>([]);
  const [selectedUser, setSelectedUser] = useState<string>('all');
  const [filteredEvents, setFilteredEvents] = useState<BlockchainEvent[]>([]);
  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
  
  // Load users and events
  useEffect(() => {
    setUsers(USERS);
    setEvents(BLOCKCHAIN_EVENTS);
  }, []);
  
  // Filter events based on selected user and event type
  useEffect(() => {
    let filtered = [...events];
    
    // Filter by user
    if (selectedUser !== 'all') {
      filtered = filtered.filter(event => event.userId === selectedUser);
    }
    
    // Filter by event type
    if (eventTypeFilter !== 'all') {
      filtered = filtered.filter(event => event.eventType === eventTypeFilter);
    }
    
    // Sort by timestamp descending (newest first)
    filtered.sort((a, b) => b.timestamp - a.timestamp);
    
    setFilteredEvents(filtered);
  }, [events, selectedUser, eventTypeFilter]);
  
  // Get event icon
  const getEventIcon = (eventType: string): string => {
    switch (eventType) {
      case 'user-registration':
        return '👤';
      case 'bag-issuance':
        return '🛍️';
      case 'disposal':
        return '🗑️';
      case 'reward':
        return '🏆';
      case 'fine':
        return '💸';
      default:
        return '📝';
    }
  };
  
  // Format timestamp
  const formatDate = (timestamp: number): string => {
    return new Date(timestamp).toLocaleString();
  };
  
  // Format currency
  const formatCurrency = (amount: number): string => {
    return `$${amount.toFixed(2)}`;
  };
  
  // Get user name by ID
  const getUserName = (userId: string): string => {
    const user = users.find(u => u.id === userId);
    return user ? user.name : 'Unknown User';
  };
  
  // Get event description
  const getEventDescription = (event: BlockchainEvent): string => {
    const userName = event.userId ? getUserName(event.userId) : 'Unknown User';
    
    switch (event.eventType) {
      case 'user-registration':
        return `${userName} registered`;
      case 'bag-issuance':
        return `${userName} was issued a new bag`;
      case 'disposal':
        if (event.correct) {
          return `${userName} correctly disposed waste`;
        } else {
          return `${userName} incorrectly disposed waste`;
        }
      case 'reward':
        return `${userName} earned ${event.pointsAwarded} points`;
      case 'fine':
        return `${userName} was fined ${formatCurrency(event.fineAmount || 0)}`;
      default:
        return 'Unknown event';
    }
  };
  
  // Calculate total stats
  const getTotalStats = () => {
    const stats = {
      totalPoints: 0,
      totalFines: 0,
      totalUsers: users.length,
      totalDisposals: 0,
      correctDisposals: 0
    };
    
    users.forEach(user => {
      stats.totalPoints += user.pointsBalance;
      stats.totalFines += user.finesBalance;
    });
    
    events.forEach(event => {
      if (event.eventType === 'disposal') {
        stats.totalDisposals++;
        if (event.correct) {
          stats.correctDisposals++;
        }
      }
    });
    
    return stats;
  };
  
  const stats = getTotalStats();
  
  return (
    <div className="flex flex-col gap-5">
      <GlassCard>
        <h2 className="text-xl font-semibold mb-4">Points & Fines Dashboard</h2>
        
        {/* Stats Cards */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-5">
          <div className="bg-slate-800 p-3 rounded-lg">
            <div className="text-3xl font-semibold text-blue-400">{stats.totalPoints}</div>
            <div className="text-xs text-gray-400">Total Points</div>
          </div>
          
          <div className="bg-slate-800 p-3 rounded-lg">
            <div className="text-3xl font-semibold text-red-400">${stats.totalFines}</div>
            <div className="text-xs text-gray-400">Total Fines</div>
          </div>
          
          <div className="bg-slate-800 p-3 rounded-lg">
            <div className="text-3xl font-semibold text-purple-400">{stats.totalUsers}</div>
            <div className="text-xs text-gray-400">Total Users</div>
          </div>
          
          <div className="bg-slate-800 p-3 rounded-lg">
            <div className="text-3xl font-semibold text-yellow-400">{stats.totalDisposals}</div>
            <div className="text-xs text-gray-400">Total Disposals</div>
          </div>
          
          <div className="bg-slate-800 p-3 rounded-lg">
            <div className="text-3xl font-semibold text-green-400">
              {stats.totalDisposals ? Math.round((stats.correctDisposals / stats.totalDisposals) * 100) : 0}%
            </div>
            <div className="text-xs text-gray-400">Correct Disposal Rate</div>
          </div>
        </div>
        
        {/* User Table */}
        <div className="w-full overflow-x-auto mb-5">
          <table className="w-full text-sm">
            <thead>
              <tr className="bg-slate-800 text-gray-300">
                <th className="px-4 py-2 text-left">User</th>
                <th className="px-4 py-2 text-right">Points Balance</th>
                <th className="px-4 py-2 text-right">Fines Balance</th>
                <th className="px-4 py-2 text-right">Net Balance</th>
              </tr>
            </thead>
            <tbody>
              {users.map(user => (
                <tr 
                  key={user.id} 
                  className="border-b border-gray-700 hover:bg-slate-800 cursor-pointer"
                  onClick={() => setSelectedUser(user.id === selectedUser ? 'all' : user.id)}
                >
                  <td className="px-4 py-2">
                    <div className="font-medium">{user.name}</div>
                    <div className="text-xs text-gray-400 truncate max-w-[200px]">{user.walletAddress}</div>
                  </td>
                  <td className="px-4 py-2 text-right">
                    <span className="text-blue-400 font-medium">{user.pointsBalance} pts</span>
                  </td>
                  <td className="px-4 py-2 text-right">
                    <span className="text-red-400 font-medium">${user.finesBalance}</span>
                  </td>
                  <td className="px-4 py-2 text-right">
                    <span className={`font-medium ${
                      user.pointsBalance - user.finesBalance > 0 
                        ? 'text-green-400' 
                        : 'text-red-400'
                    }`}>
                      {user.pointsBalance - user.finesBalance > 0 ? '+' : ''}
                      {user.pointsBalance - user.finesBalance}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </GlassCard>
      
      {/* Blockchain Events Timeline */}
      <GlassCard>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">Blockchain Timeline</h2>
          
          <div className="flex gap-2">
            <select
              value={selectedUser}
              onChange={(e) => setSelectedUser(e.target.value)}
              className="bg-slate-800 border border-slate-700 rounded-md p-1 text-sm text-white"
            >
              <option value="all">All Users</option>
              {users.map(user => (
                <option key={user.id} value={user.id}>{user.name}</option>
              ))}
            </select>
            
            <select
              value={eventTypeFilter}
              onChange={(e) => setEventTypeFilter(e.target.value)}
              className="bg-slate-800 border border-slate-700 rounded-md p-1 text-sm text-white"
            >
              <option value="all">All Events</option>
              <option value="user-registration">User Registration</option>
              <option value="bag-issuance">Bag Issuance</option>
              <option value="disposal">Disposal</option>
              <option value="reward">Rewards</option>
              <option value="fine">Fines</option>
            </select>
          </div>
        </div>
        
        {filteredEvents.length === 0 ? (
          <div className="p-4 text-center text-gray-400">
            No events to display
          </div>
        ) : (
          <div className="space-y-3">
            {filteredEvents.map(event => (
              <div key={event.id} className="p-3 bg-slate-800 rounded-md">
                <div className="flex">
                  <div className="mr-3 text-2xl">{getEventIcon(event.eventType)}</div>
                  <div className="flex-1">
                    <div className="font-medium">{getEventDescription(event)}</div>
                    <div className="text-xs text-gray-400">{formatDate(event.timestamp)}</div>
                    <div className="flex mt-1">
                      {event.eventType === 'disposal' && (
                        <span className={`text-xs px-2 py-0.5 rounded-full ${
                          event.correct
                            ? 'bg-green-500/20 text-green-300'
                            : 'bg-red-500/20 text-red-300'
                        }`}>
                          {event.correct ? 'Correct' : 'Incorrect'} Disposal
                        </span>
                      )}
                      {event.eventType === 'reward' && (
                        <span className="text-xs px-2 py-0.5 rounded-full bg-blue-500/20 text-blue-300">
                          +{event.pointsAwarded} Points
                        </span>
                      )}
                      {event.eventType === 'fine' && (
                        <span className="text-xs px-2 py-0.5 rounded-full bg-red-500/20 text-red-300">
                          ${event.fineAmount} Fine
                        </span>
                      )}
                    </div>
                  </div>
                  <div className="text-right">
                    <a 
                      href={`https://etherscan.io/tx/${event.txHash}`}
                      target="_blank"
                      rel="noopener noreferrer" 
                      className="text-xs text-blue-400 hover:underline"
                    >
                      View Transaction ↗
                    </a>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </GlassCard>
    </div>
  );
};

export default PointsDashboard; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/garbage/BinScanner.tsx ---
import React, { useState, useEffect } from 'react';
import { BAGS, USERS, blockchainAdapter } from '../../utils/garbageDummyData';
import GlassCard from '../GlassCard';

type Bag = {
  id: string;
  userId: string;
  bagType: string;
  qrCode: string;
  rfid: string;
  issuedAt: number;
  txHash: string;
};

type User = {
  id: string;
  name: string;
  address: string;
  walletAddress: string;
  pointsBalance: number;
  finesBalance: number;
  onboardedAt: number;
};

type BinScannerProps = {
  selectedBin: string | null;
  binType: string | null;
  onScanComplete?: (disposalData: any) => void;
};

const BinScanner: React.FC<BinScannerProps> = ({ 
  selectedBin, 
  binType, 
  onScanComplete 
}) => {
  const [scanInput, setScanInput] = useState<string>('');
  const [scanning, setScanning] = useState<boolean>(false);
  const [scanResult, setScanResult] = useState<any>(null);
  const [scanError, setScanError] = useState<string>('');
  const [scannedBag, setScannedBag] = useState<Bag | null>(null);
  const [scannedUser, setScannedUser] = useState<User | null>(null);
  const [randomBags, setRandomBags] = useState<Bag[]>([]);
  
  // Load random bags for demo purposes
  useEffect(() => {
    const getRandomBags = () => {
      // Get 5 random bags from the BAGS array
      const shuffled = [...BAGS].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, 5);
    };
    
    setRandomBags(getRandomBags());
  }, []);
  
  // Reset scan input when bin changes
  useEffect(() => {
    setScanInput('');
    setScanResult(null);
    setScanError('');
    setScannedBag(null);
    setScannedUser(null);
  }, [selectedBin, binType]);
  
  // Handle scan input change
  const handleScanInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setScanInput(e.target.value);
  };
  
  // Handle quick selection of a bag for demo
  const handleQuickSelect = (bagIdOrCode: string) => {
    setScanInput(bagIdOrCode);
  };
  
  // Process scan to find the bag
  const findBagByIdOrCode = (query: string): Bag | null => {
    return BAGS.find(
      bag => bag.id === query || bag.qrCode === query || bag.rfid === query
    ) || null;
  };
  
  // Find user by ID
  const findUserById = (userId: string): User | null => {
    return USERS.find(user => user.id === userId) || null;
  };
  
  // Handle scan submission
  const handleScan = async () => {
    if (!scanInput.trim()) {
      setScanError('Please enter a bag ID, QR code, or RFID');
      return;
    }
    
    if (!selectedBin || !binType) {
      setScanError('No bin selected');
      return;
    }
    
    setScanning(true);
    setScanResult(null);
    setScanError('');
    
    try {
      // Simulate scanning delay
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Find bag by ID, QR, or RFID
      const bag = findBagByIdOrCode(scanInput);
      
      if (!bag) {
        throw new Error('Invalid or unknown bag identifier');
      }
      
      // Find user
      const user = findUserById(bag.userId);
      
      if (!user) {
        throw new Error('User not found for this bag');
      }
      
      // Set scanned bag and user
      setScannedBag(bag);
      setScannedUser(user);
      
      // Record disposal via blockchain adapter
      const disposalData = {
        sensorId: selectedBin,
        userId: bag.userId,
        bagId: bag.id,
        timestamp: Date.now()
      };
      
      const result = blockchainAdapter.recordDisposal(disposalData);
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      // Determine points or fine
      if (result.correct) {
        // Award points (1-5 points for correct disposal)
        const points = Math.floor(Math.random() * 5) + 1;
        const rewardResult = blockchainAdapter.issueReward(bag.userId, points);
        
        // Update result with points
        result.points = points;
        result.rewardTxHash = rewardResult.txHash;
      } else {
        // Issue fine ($5-$20 for incorrect disposal)
        const fineAmount = (Math.floor(Math.random() * 4) + 1) * 5;
        const fineResult = blockchainAdapter.issueFine(bag.userId, fineAmount);
        
        // Update result with fine
        result.fineAmount = fineAmount;
        result.fineTxHash = fineResult.txHash;
      }
      
      // Set scan result
      setScanResult(result);
      
      // Call onScanComplete callback if provided
      if (onScanComplete) {
        onScanComplete(result);
      }
    } catch (error) {
      console.error('Scan error:', error);
      setScanError(error.message || 'An error occurred during scanning');
    } finally {
      setScanning(false);
    }
  };
  
  // Return appropriate text for bag type
  const getBagTypeText = (type: string) => {
    switch (type) {
      case 'general-waste':
        return 'General Waste';
      case 'recyclable':
        return 'Recyclable';
      case 'organic':
        return 'Organic';
      default:
        return type;
    }
  };
  
  return (
    <GlassCard>
      <h2 className="text-xl font-semibold mb-4">
        Manual Bag Scanner
        {binType && <span className="ml-2 text-sm text-gray-400">({getBagTypeText(binType)} Bin)</span>}
      </h2>
      
      {!selectedBin || !binType ? (
        <div className="p-4 text-center text-gray-400">
          Please select a bin to enable scanning
        </div>
      ) : (
        <>
          <div className="mb-4">
            <p className="text-gray-300 text-sm mb-3">
              This scanner simulates the process of manually scanning waste bags when they are 
              disposed at bins. Operators can scan bags by ID, QR code, or RFID to record proper disposal 
              and assign rewards or fines based on correct sorting.
            </p>
            
            <label htmlFor="scanInput" className="block text-sm font-medium text-gray-300 mb-1">
              Scan Bag (ID, QR Code, or RFID)
            </label>
            <div className="flex">
              <input
                type="text"
                id="scanInput"
                value={scanInput}
                onChange={handleScanInputChange}
                disabled={scanning}
                className="flex-1 bg-slate-800 border border-slate-700 rounded-l-md p-2 text-white"
                placeholder="Enter bag ID, QR code, or RFID"
              />
              <button
                onClick={handleScan}
                disabled={scanning || !scanInput.trim()}
                className={`px-4 rounded-r-md ${
                  scanning || !scanInput.trim()
                    ? 'bg-gray-600 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                } text-white font-medium transition-colors`}
              >
                {scanning ? 'Scanning...' : 'Scan'}
              </button>
            </div>
          </div>
          
          {scanError && (
            <div className="mb-4 p-3 bg-red-500/20 border border-red-500 rounded-md text-red-300">
              {scanError}
            </div>
          )}
          
          {/* Quick selection for demo purposes */}
          <div className="mb-4">
            <div className="text-sm text-gray-400 mb-2">Quick Select for Demo:</div>
            <div className="flex flex-wrap gap-2">
              {randomBags.map(bag => (
                <button
                  key={bag.id}
                  onClick={() => handleQuickSelect(bag.id)}
                  className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs text-white transition-colors"
                >
                  {bag.id}
                </button>
              ))}
            </div>
          </div>
          
          {/* Scan result */}
          {scanResult && (
            <div className={`p-4 rounded-md ${
              scanResult.correct 
                ? 'bg-green-500/20 border border-green-500' 
                : 'bg-red-500/20 border border-red-500'
            }`}>
              <div className="flex items-center mb-3">
                <div className={`text-2xl mr-2 ${
                  scanResult.correct ? 'text-green-400' : 'text-red-400'
                }`}>
                  {scanResult.correct ? '✓' : '✗'}
                </div>
                <div className="text-lg font-medium">
                  {scanResult.correct 
                    ? 'Correct Disposal' 
                    : 'Incorrect Disposal'}
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-2 mb-3">
                <div>
                  <span className="text-gray-400 text-sm">User:</span>
                  <div>{scannedUser?.name}</div>
                </div>
                <div>
                  <span className="text-gray-400 text-sm">Bag ID:</span>
                  <div>{scannedBag?.id}</div>
                </div>
                <div>
                  <span className="text-gray-400 text-sm">Bag Type:</span>
                  <div className="capitalize">{scannedBag?.bagType.replace('-', ' ')}</div>
                </div>
                <div>
                  <span className="text-gray-400 text-sm">Bin Type:</span>
                  <div className="capitalize">{binType.replace('-', ' ')}</div>
                </div>
              </div>
              
              {scanResult.correct ? (
                <div className="text-green-300 font-medium">
                  +{scanResult.points} points awarded
                  <div className="text-xs mt-1">
                    <a 
                      href={`https://etherscan.io/tx/${scanResult.rewardTxHash}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-400 hover:underline"
                    >
                      View reward on Etherscan ↗
                    </a>
                  </div>
                </div>
              ) : (
                <div className="text-red-300 font-medium">
                  ${scanResult.fineAmount} fine issued
                  <div className="text-xs mt-1">
                    <a 
                      href={`https://etherscan.io/tx/${scanResult.fineTxHash}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-400 hover:underline"
                    >
                      View fine on Etherscan ↗
                    </a>
                  </div>
                </div>
              )}
              
              <div className="mt-3 text-xs text-gray-400">
                Disposal recorded on blockchain:
                <a 
                  href={`https://etherscan.io/tx/${scanResult.txHash}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="ml-2 text-blue-400 hover:underline"
                >
                  View on Etherscan ↗
                </a>
              </div>
            </div>
          )}
        </>
      )}
    </GlassCard>
  );
};

export default BinScanner; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/garbage/BagAssignment.tsx ---
import React, { useState, useEffect } from 'react';
import { USERS, BAGS, blockchainAdapter } from '../../utils/garbageDummyData';
import GlassCard from '../GlassCard';

type User = {
  id: string;
  name: string;
  address: string;
  walletAddress: string;
  pointsBalance: number;
  finesBalance: number;
  onboardedAt: number;
};

type Bag = {
  id: string;
  userId: string;
  bagType: string;
  qrCode: string;
  rfid: string;
  issuedAt: number;
  txHash: string;
};

const BagAssignment: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [bags, setBags] = useState<Bag[]>([]);
  const [selectedUserId, setSelectedUserId] = useState<string>('');
  const [filteredBags, setFilteredBags] = useState<Bag[]>([]);
  const [bagType, setBagType] = useState<string>('general-waste');
  const [issuingBag, setIssuingBag] = useState<boolean>(false);
  const [successMessage, setSuccessMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');
  
  // Load users and bags on component mount
  useEffect(() => {
    setUsers([...USERS]);
    setBags([...BAGS]);
  }, []);
  
  // Filter bags when selectedUserId changes
  useEffect(() => {
    if (selectedUserId) {
      setFilteredBags(bags.filter(bag => bag.userId === selectedUserId));
    } else {
      setFilteredBags(bags.slice(0, 20)); // Show first 20 bags when no user is selected
    }
  }, [selectedUserId, bags]);
  
  // Format date
  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleString();
  };
  
  // Get user by ID
  const getUserById = (userId: string) => {
    return users.find(user => user.id === userId) || null;
  };
  
  // Style for bag type badge
  const getBagTypeBadge = (type: string) => {
    switch (type) {
      case 'general-waste':
        return 'bg-gray-500/30 text-gray-300';
      case 'recyclable':
        return 'bg-blue-500/30 text-blue-300';
      case 'organic':
        return 'bg-green-500/30 text-green-300';
      default:
        return 'bg-purple-500/30 text-purple-300';
    }
  };
  
  // Handle issuing a new bag
  const handleIssueBag = async () => {
    if (!selectedUserId) {
      setErrorMessage('Please select a user first');
      return;
    }
    
    setIssuingBag(true);
    setSuccessMessage('');
    setErrorMessage('');
    
    try {
      // Determine next bag number for this user
      const userBags = bags.filter(bag => bag.userId === selectedUserId);
      const nextBagNumber = userBags.length + 1;
      
      // Create new bag data
      const newBagData = {
        id: `bag-${selectedUserId.split('-')[1]}-${nextBagNumber.toString().padStart(2, '0')}`,
        userId: selectedUserId,
        bagType,
        qrCode: `QR-${Math.random().toString(36).substring(2, 14)}`,
        rfid: `RFID-${Math.random().toString(36).substring(2, 18)}`
      };
      
      // Call blockchain adapter to issue bag
      const newBag = blockchainAdapter.issueBag(newBagData);
      
      // Update local state
      setBags(prevBags => [newBag, ...prevBags]);
      
      // Update filtered bags
      if (selectedUserId) {
        setFilteredBags(prevFiltered => [newBag, ...prevFiltered]);
      }
      
      // Show success message
      const user = getUserById(selectedUserId);
      setSuccessMessage(`Successfully issued a new ${bagType} bag to ${user?.name || selectedUserId}`);
      
      // Clear success message after 5 seconds
      setTimeout(() => {
        setSuccessMessage('');
      }, 5000);
    } catch (error) {
      console.error('Error issuing bag:', error);
      setErrorMessage(error.message || 'Failed to issue bag');
    } finally {
      setIssuingBag(false);
    }
  };
  
  return (
    <div className="flex flex-col space-y-6">
      <GlassCard>
        <h2 className="text-xl font-semibold mb-4">Issue New Bag</h2>
        
        {successMessage && (
          <div className="mb-4 p-3 bg-green-500/20 border border-green-500 rounded-md text-green-300">
            {successMessage}
          </div>
        )}
        
        {errorMessage && (
          <div className="mb-4 p-3 bg-red-500/20 border border-red-500 rounded-md text-red-300">
            {errorMessage}
          </div>
        )}
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div>
            <label htmlFor="selectedUser" className="block text-sm font-medium text-gray-300 mb-1">
              Select User
            </label>
            <select
              id="selectedUser"
              value={selectedUserId}
              onChange={(e) => setSelectedUserId(e.target.value)}
              className="w-full bg-slate-800 border border-slate-700 rounded-md p-2 text-white"
            >
              <option value="">-- Select User --</option>
              {users.map(user => (
                <option key={user.id} value={user.id}>
                  {user.name} ({user.id})
                </option>
              ))}
            </select>
          </div>
          
          <div>
            <label htmlFor="bagType" className="block text-sm font-medium text-gray-300 mb-1">
              Bag Type
            </label>
            <select
              id="bagType"
              value={bagType}
              onChange={(e) => setBagType(e.target.value)}
              className="w-full bg-slate-800 border border-slate-700 rounded-md p-2 text-white"
            >
              <option value="general-waste">General Waste</option>
              <option value="recyclable">Recyclable</option>
              <option value="organic">Organic</option>
            </select>
          </div>
          
          <div className="flex items-end">
            <button
              type="button"
              onClick={handleIssueBag}
              disabled={issuingBag || !selectedUserId}
              className={`w-full py-2 px-4 rounded-md ${
                issuingBag || !selectedUserId
                  ? 'bg-gray-600 cursor-not-allowed' 
                  : 'bg-green-600 hover:bg-green-700'
              } text-white font-medium transition-colors`}
            >
              {issuingBag ? 'Issuing...' : 'Issue New Bag'}
            </button>
          </div>
        </div>
        
        {selectedUserId && (
          <div className="mt-4 p-3 bg-slate-800/50 rounded-md">
            <h3 className="text-md font-medium text-white mb-2">Selected User Details</h3>
            {(() => {
              const user = getUserById(selectedUserId);
              if (!user) return <p className="text-gray-400">User not found</p>;
              
              return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm">
                  <div>
                    <span className="text-gray-400">Name:</span> {user.name}
                  </div>
                  <div>
                    <span className="text-gray-400">ID:</span> {user.id}
                  </div>
                  <div className="md:col-span-2">
                    <span className="text-gray-400">Address:</span> {user.address}
                  </div>
                  <div>
                    <span className="text-gray-400">Points:</span> <span className="text-green-400">{user.pointsBalance} pts</span>
                  </div>
                  <div>
                    <span className="text-gray-400">Fines:</span> <span className="text-red-400">${user.finesBalance}</span>
                  </div>
                </div>
              );
            })()}
          </div>
        )}
      </GlassCard>
      
      <GlassCard>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">
            {selectedUserId 
              ? `Bags for ${getUserById(selectedUserId)?.name || selectedUserId}` 
              : 'All Issued Bags'}
          </h2>
          <div className="flex items-center">
            {selectedUserId && (
              <button
                onClick={() => setSelectedUserId('')}
                className="mr-3 text-sm text-gray-400 hover:text-white"
              >
                Clear Filter
              </button>
            )}
            <div className="text-sm text-gray-400">
              {selectedUserId 
                ? `Showing ${filteredBags.length} bags` 
                : `Showing 20 of ${bags.length} bags`}
            </div>
          </div>
        </div>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-slate-700">
            <thead>
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Bag ID
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  User
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Type
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  QR Code
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  RFID
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Issued At
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  On-chain
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-slate-700">
              {filteredBags.map((bag) => (
                <tr key={bag.id} className="hover:bg-slate-700/50">
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-white">
                    {bag.id}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-white">
                    {getUserById(bag.userId)?.name || bag.userId}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm">
                    <span className={`px-2 py-1 rounded-full text-xs ${getBagTypeBadge(bag.bagType)}`}>
                      {bag.bagType.replace('-', ' ')}
                    </span>
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300 font-mono">
                    {bag.qrCode}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300 font-mono">
                    {bag.rfid}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300">
                    {formatDate(bag.issuedAt)}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-blue-400">
                    <a
                      href={`https://etherscan.io/tx/${bag.txHash}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="hover:underline"
                    >
                      View on Etherscan ↗
                    </a>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        
        {filteredBags.length === 0 && (
          <div className="text-center py-8 text-gray-400">
            No bags found for the selected criteria
          </div>
        )}
      </GlassCard>
    </div>
  );
};

export default BagAssignment; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/garbage/UserOnboarding.tsx ---
import React, { useState, useEffect } from 'react';
import { USERS, blockchainAdapter } from '../../utils/garbageDummyData';
import GlassCard from '../GlassCard';

type User = {
  id: string;
  name: string;
  address: string;
  walletAddress: string;
  pointsBalance: number;
  finesBalance: number;
  onboardedAt: number;
};

const UserOnboarding: React.FC = () => {
  // State for form inputs
  const [name, setName] = useState<string>('');
  const [address, setAddress] = useState<string>('');
  const [walletAddress, setWalletAddress] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [users, setUsers] = useState<User[]>([]);
  const [successMessage, setSuccessMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');
  
  // Load users on component mount
  useEffect(() => {
    setUsers([...USERS]);
  }, []);
  
  // Generate a random wallet address
  const generateRandomWallet = () => {
    const characters = '0123456789abcdef';
    let wallet = '0x';
    for (let i = 0; i < 40; i++) {
      wallet += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    setWalletAddress(wallet);
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setSuccessMessage('');
    setErrorMessage('');
    
    try {
      if (!name || !address || !walletAddress) {
        throw new Error('All fields are required');
      }
      
      // Call blockchain adapter to register user
      const newUser = blockchainAdapter.registerUser({
        name,
        address,
        walletAddress,
        pointsBalance: 0,
        finesBalance: 0
      });
      
      // Update local state
      setUsers(prevUsers => [newUser, ...prevUsers]);
      
      // Reset form
      setName('');
      setAddress('');
      setWalletAddress('');
      
      // Show success message
      setSuccessMessage(`User ${newUser.name} successfully registered with ID: ${newUser.id}`);
      
      // Clear success message after 5 seconds
      setTimeout(() => {
        setSuccessMessage('');
      }, 5000);
    } catch (error) {
      console.error('Error registering user:', error);
      setErrorMessage(error.message || 'Failed to register user');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="flex flex-col space-y-6">
      <GlassCard>
        <h2 className="text-xl font-semibold mb-4">Register New User</h2>
        
        {successMessage && (
          <div className="mb-4 p-3 bg-green-500/20 border border-green-500 rounded-md text-green-300">
            {successMessage}
          </div>
        )}
        
        {errorMessage && (
          <div className="mb-4 p-3 bg-red-500/20 border border-red-500 rounded-md text-red-300">
            {errorMessage}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-300 mb-1">
              Full Name
            </label>
            <input
              type="text"
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full bg-slate-800 border border-slate-700 rounded-md p-2 text-white"
              placeholder="Enter full name"
            />
          </div>
          
          <div>
            <label htmlFor="address" className="block text-sm font-medium text-gray-300 mb-1">
              Home Address
            </label>
            <input
              type="text"
              id="address"
              value={address}
              onChange={(e) => setAddress(e.target.value)}
              className="w-full bg-slate-800 border border-slate-700 rounded-md p-2 text-white"
              placeholder="Enter home address"
            />
          </div>
          
          <div>
            <label htmlFor="walletAddress" className="block text-sm font-medium text-gray-300 mb-1">
              Wallet Address
            </label>
            <div className="flex">
              <input
                type="text"
                id="walletAddress"
                value={walletAddress}
                onChange={(e) => setWalletAddress(e.target.value)}
                className="flex-1 bg-slate-800 border border-slate-700 rounded-l-md p-2 text-white"
                placeholder="Enter Ethereum wallet address"
              />
              <button
                type="button"
                onClick={generateRandomWallet}
                className="bg-indigo-600 hover:bg-indigo-700 text-white px-3 rounded-r-md"
              >
                Generate
              </button>
            </div>
          </div>
          
          <div className="pt-2">
            <button
              type="submit"
              disabled={isSubmitting}
              className={`w-full py-2 px-4 rounded-md ${
                isSubmitting 
                  ? 'bg-gray-600 cursor-not-allowed' 
                  : 'bg-green-600 hover:bg-green-700'
              } text-white font-medium transition-colors`}
            >
              {isSubmitting ? 'Registering...' : 'Register User'}
            </button>
          </div>
        </form>
      </GlassCard>
      
      <GlassCard>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">Registered Users</h2>
          <div className="text-sm text-gray-400">
            Total: {users.length}
          </div>
        </div>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-slate-700">
            <thead>
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  ID
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Name
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Address
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Wallet
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Points
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Fines
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                  Onboarded
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-slate-700">
              {users.slice(0, 10).map((user) => (
                <tr key={user.id} className="hover:bg-slate-700/50">
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-white">
                    {user.id}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-white">
                    {user.name}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300">
                    {user.address.length > 25 ? `${user.address.substring(0, 25)}...` : user.address}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300">
                    {`${user.walletAddress.substring(0, 6)}...${user.walletAddress.substring(user.walletAddress.length - 4)}`}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-green-400">
                    {user.pointsBalance} pts
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-red-400">
                    ${user.finesBalance}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-300">
                    {new Date(user.onboardedAt).toLocaleDateString()}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        
        {users.length > 10 && (
          <div className="mt-4 text-center text-sm text-gray-400">
            Showing 10 of {users.length} users
          </div>
        )}
      </GlassCard>
    </div>
  );
};

export default UserOnboarding; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/components/garbage/GarbageTimeline.tsx ---
import React from 'react';

type GarbageBlockchainEvent = {
  id: string;
  timestamp: number;
  txHash: string;
  eventType: string;
  userId?: string;
  bagId?: string;
  sensorId?: string;
  amount?: number;
  correct?: boolean;
  pointsAwarded?: number;
  fineAmount?: number;
};

type GarbageTimelineProps = {
  events: GarbageBlockchainEvent[];
};

const GarbageTimeline: React.FC<GarbageTimelineProps> = ({ events }) => {
  if (events.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-gray-300">
        <p>No blockchain events yet</p>
        <p className="text-sm mt-2">Events will appear here when actions are recorded on-chain</p>
      </div>
    );
  }

  // Get event icon
  const getEventIcon = (eventType: string): string => {
    switch (eventType) {
      case 'user-registration':
        return '👤';
      case 'bag-issuance':
        return '🛍️';
      case 'disposal':
        return '🗑️';
      case 'reward':
        return '🏆';
      case 'fine':
        return '💸';
      case 'fillLevelAlert':
        return '📊';
      case 'collectionConfirmed':
        return '♻️';
      case 'doorOpenAlert':
        return '🚪';
      case 'batteryLow':
        return '🔋';
      default:
        return '📝';
    }
  };
  
  // Helper to get color class for the event
  const getEventColorClass = (event: GarbageBlockchainEvent): string => {
    switch (event.eventType) {
      case 'disposal':
        return event.correct ? 'text-green-400' : 'text-red-400';
      case 'reward':
        return 'text-blue-400';
      case 'fine':
        return 'text-red-400';
      case 'fillLevelAlert':
        return 'text-yellow-400';
      case 'batteryLow':
        return 'text-red-400';
      case 'collectionConfirmed':
        return 'text-green-400';
      case 'doorOpenAlert':
        return 'text-yellow-400';
      default:
        return 'text-green-400';
    }
  };

  // Helper to format event description
  const getEventDescription = (event: GarbageBlockchainEvent): string => {
    switch (event.eventType) {
      case 'user-registration':
        return `User registered`;
      case 'bag-issuance':
        return `Bag issued: ${event.bagId}`;
      case 'disposal':
        return `Waste disposal: ${event.correct ? 'Correct' : 'Incorrect'}`;
      case 'reward':
        return `Reward: ${event.pointsAwarded} points`;
      case 'fine':
        return `Fine: $${event.fineAmount}`;
      case 'fillLevelAlert':
        return 'Fill level alert';
      case 'collectionConfirmed':
        return 'Bin emptied';
      case 'doorOpenAlert':
        return 'Door opened';
      case 'batteryLow':
        return 'Low battery';
      default:
        return event.eventType;
    }
  };

  return (
    <div className="h-full overflow-auto pr-2">
      <div className="space-y-4">
        {events.map((event, index) => (
          <div 
            key={`${event.txHash}-${index}`}
            className="relative pl-6 border-l border-green-500/50"
          >
            {/* Timeline dot */}
            <div className="absolute left-0 top-0 -translate-x-1/2 w-3 h-3 rounded-full bg-green-500"></div>
            
            {/* Event content */}
            <div className="mb-2">
              <div className="flex items-center">
                <span className="mr-2 text-xl">{getEventIcon(event.eventType)}</span>
                <h4 className="text-white text-sm font-medium">
                  {getEventDescription(event)}
                </h4>
              </div>
              <p className="text-gray-300 text-xs mt-1">
                {new Date(event.timestamp).toLocaleString()}
              </p>
              <div className="flex mt-1">
                {event.eventType === 'disposal' && (
                  <span className={`text-xs px-2 py-0.5 rounded-full ${
                    event.correct
                      ? 'bg-green-500/20 text-green-300'
                      : 'bg-red-500/20 text-red-300'
                  }`}>
                    {event.correct ? 'Correct' : 'Incorrect'} Disposal
                  </span>
                )}
                {event.eventType === 'reward' && (
                  <span className="text-xs px-2 py-0.5 rounded-full bg-blue-500/20 text-blue-300">
                    +{event.pointsAwarded} Points
                  </span>
                )}
                {event.eventType === 'fine' && (
                  <span className="text-xs px-2 py-0.5 rounded-full bg-red-500/20 text-red-300">
                    ${event.fineAmount} Fine
                  </span>
                )}
              </div>
              <a
                href={`https://etherscan.io/tx/${event.txHash}`}
                target="_blank"
                rel="noopener noreferrer"
                className="text-xs text-blue-400 hover:underline mt-1 inline-block"
              >
                View on Etherscan ↗
              </a>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default GarbageTimeline; 

================================================================================

SCANNING: /home/ayes/water-quality-monitor/frontend/pages
================================================================================

Directory: /home/ayes/water-quality-monitor/frontend/pages

--- FILE: /home/ayes/water-quality-monitor/frontend/pages/index.js ---
import { useRouter } from 'next/router';
import GlassCard from '../components/GlassCard';

export default function Home() {
  const router = useRouter();

  return (
    <div className="min-h-screen flex items-center justify-center p-6">
      <GlassCard className="max-w-2xl w-full text-center">
        <h1 className="text-4xl font-bold text-white mb-6">Panama Smart City</h1>
        <p className="text-gray-200 mb-8">
          A smart city platform for Panama City integrated with blockchain technology and IoT sensors for realtime data collection and analysis
        </p>
        
        <div className="flex flex-col md:flex-row gap-4 justify-center">
          
          <button
            className="bg-accentBlue text-white py-3 px-6 rounded-lg hover:bg-opacity-80 transition"
            onClick={() => router.push('/test/dashboard')}
          >
            View Test Dashboard
          </button>
          
          <button
            className="bg-green-600 text-white py-3 px-6 rounded-lg hover:bg-opacity-80 transition"
            onClick={() => router.push('/garbage-management')}
          >
            Garbage Management
          </button>
          
          <button
            className="bg-green-600 text-white py-3 px-6 rounded-lg hover:bg-opacity-80 transition"
            onClick={() => router.push('/test/garbage-dashboard')}
          >
            Test Garbage Dashboard
          </button>
          
          <a
            href="https://github.com/yourusername/water-quality-monitor"
            target="_blank"
            rel="noopener noreferrer"
            className="bg-white/10 text-white py-3 px-6 rounded-lg hover:bg-opacity-20 transition"
          >
            GitHub Repository
          </a>
        </div>
        
        <div className="mt-12 text-sm text-gray-300">
          <p>Built with Next.js, Tailwind CSS, Nest.js, and Hardhat</p>
        </div>
      </GlassCard>
    </div>
  );
}


================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/pages/dashboard.tsx ---
// Add global declaration for window.ethereum
declare global {
  interface Window {
    ethereum: any;
  }
}

import React, { useState, useEffect, useRef, useCallback } from 'react';
import axios from 'axios';
import { ethers } from 'ethers';
import { Line } from 'react-chartjs-2';
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  PointElement, 
  LineElement, 
  Title, 
  Tooltip, 
  Legend,
  ChartOptions,
  ChartData
} from 'chart.js';
import GlassCard from '../components/GlassCard';
import SensorMap from '../components/SensorMap';
import Timeline from '../components/Timeline';
import SensorDetails from '../components/SensorDetails';
import MetricsChart from '../components/MetricsChart';
import { SENSOR_IDS, generateDummyReadings, generateDummyEvents, PANAMA_CITY_SENSORS } from '../utils/dummyData';

// Register ChartJS components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Enhanced Reading type with all possible metrics
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  latitude?: number;
  longitude?: number;
  txHash?: string;
  
  // Water Quality
  turbidity?: number;
  pH?: number;
  temperature?: number;
  conductivity?: number;
  tds?: number;
  dissolvedOxygen?: number;
  chlorineResidual?: number;
  orp?: number;
  nitrates?: number;
  phosphates?: number;
  ammonia?: number;
  hardness?: number;
  
  // Flow & Hydraulic
  flowRate?: number;
  pressure?: number;
  velocity?: number;
  cumulativeVolume?: number;
  
  // Tank
  tankLevel?: number;
  waterDepth?: number;
  currentVolume?: number;
  
  // Pump
  pumpStatus?: boolean;
  runtime?: number;
  startStopCount?: number;
  motorCurrent?: number;
  motorVoltage?: number;
  vibration?: number;
  bearingTemperature?: number;
  energyConsumption?: number;
  
  // Valve
  valvePosition?: number;
  
  // Network & Environmental
  signalStrength?: number;
  uptime?: number;
  batteryLevel?: number;
  rainfall?: number;
  ambientTemperature?: number;
  humidity?: number;
  soilMoisture?: number;
};

// Define the event type
type BlockchainEvent = {
  sensorId: string;
  value: number;
  timestamp: number;
  txHash: string;
  metricType?: string;
};

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS;
const CONTRACT_ABI = [
  'event ReadingRecorded(bytes32 indexed sensorId, uint256 value, uint256 ts)',
];

const Dashboard = () => {
  const [readings, setReadings] = useState<Record<string, Reading[]>>({});
  const [sensors, setSensors] = useState<string[]>([]);
  const [selectedSensor, setSelectedSensor] = useState<string | null>(null);
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [events, setEvents] = useState<BlockchainEvent[]>([]);
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [activeMetricTab, setActiveMetricTab] = useState<string>('primary');
  const [alertCount, setAlertCount] = useState<number>(0);
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const [theme, setTheme] = useState<'dark' | 'light'>('dark');
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);
  const selectedSensorRef = useRef<string | null>(null); // Use ref to track selected sensor
  const activeMetricTabRef = useRef<string>('primary'); // Add ref to track the current tab
  
  // Keep the ref in sync with state
  useEffect(() => {
    activeMetricTabRef.current = activeMetricTab;
  }, [activeMetricTab]);
  
  // Create a stable callback for sensor selection
  const handleSensorSelect = useCallback((sensorId: string) => {
    console.log('User selected sensor:', sensorId);
    setSelectedSensor(sensorId);
    // Also update the ref to track selected sensor
    selectedSensorRef.current = sensorId;
    // Save selected sensor to localStorage for persistence
    localStorage.setItem('selectedSensor', sensorId);
  }, []);

  // Fetch data and initialize polling
  useEffect(() => {
    console.log('Initial data fetch');
    
    // Initial data fetch with loading state
    setIsLoading(true);
    
    // Try to restore previously selected sensor from localStorage
    const savedSensor = localStorage.getItem('selectedSensor');
    if (savedSensor) {
      setSelectedSensor(savedSensor);
      selectedSensorRef.current = savedSensor; // Also set the ref
    }
    
    // Restore previously selected metric tab from localStorage
    const savedMetricTab = localStorage.getItem('activeMetricTab');
    if (savedMetricTab) {
      setActiveMetricTab(savedMetricTab);
    }
    
    fetchReadings()
      .then(() => {
        console.log('Sensors loaded:', sensors);
        if (sensors.length === 0) {
          console.log('No sensors detected, using dummy data with IDs:', SENSOR_IDS);
          setSensors(SENSOR_IDS);
          // Only set selected sensor if nothing is currently selected
          if (selectedSensor === null) {
            const newSelectedSensor = savedSensor && SENSOR_IDS.includes(savedSensor) 
              ? savedSensor 
              : SENSOR_IDS[0];
            setSelectedSensor(newSelectedSensor);
            localStorage.setItem('selectedSensor', newSelectedSensor);
          }
        }
      })
      .finally(() => setIsLoading(false));

    // Set up polling for readings
    pollingInterval.current = setInterval(() => {
      // Capture current states
      const currentSensor = selectedSensorRef.current;
      const currentTab = activeMetricTabRef.current;
      
      console.log('Before fetching - Tab state:', currentTab);
      
      // Store states in localStorage for persistence
      if (currentTab) {
        localStorage.setItem('activeMetricTab', currentTab);
      }
      
      // Fetch new readings data
      fetchReadings().then(() => {
        console.log('After fetching - Restoring state - Tab:', currentTab, 'Sensor:', currentSensor);
        
        // Explicitly restore states to prevent loss during re-renders
        if (currentSensor && currentSensor !== selectedSensorRef.current) {
          setSelectedSensor(currentSensor);
          selectedSensorRef.current = currentSensor;
        }
        
        // Only restore tab if it's different from the current state
        // This prevents unnecessary re-renders and state flushes
        if (currentTab && currentTab !== activeMetricTabRef.current) {
          console.log('Restoring tab state after fetch to:', currentTab);
          setActiveMetricTab(currentTab);
        }
      });
      
      // Update last updated timestamp
      setLastUpdated(new Date());
    }, 5000);

    // Cleanup on unmount
    return () => {
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
    };
  }, []);

  // Connect to Ethereum provider
  const connectWallet = async () => {
    if (window.ethereum) {
      try {
        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Create provider
        const provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(provider);
        
        // Create contract instance
        if (CONTRACT_ADDRESS) {
          const contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            provider
          );
          setContract(contract);
          
          // Listen for events
          contract.on('ReadingRecorded', (sensorId, value, ts, event) => {
            const decodedSensorId = ethers.decodeBytes32String(sensorId);
            const newEvent: BlockchainEvent = {
              sensorId: decodedSensorId,
              value: Number(value),
              timestamp: Number(ts),
              txHash: event.transactionHash,
            };
            
            setEvents(prev => [newEvent, ...prev].slice(0, 20));
            // Increment alert count when new events come in
            setAlertCount(prev => prev + 1);
          });
        }
        
        setIsWalletConnected(true);
      } catch (error) {
        console.error('Error connecting to wallet:', error);
      }
    } else {
      alert('Please install MetaMask to use this feature');
    }
  };

  // Fetch readings from API
  const fetchReadings = async () => {
    // IMPORTANT: Save current state BEFORE any state changes
    const currentSelectedSensor = selectedSensorRef.current || selectedSensor;
    const currentMetricTab = activeMetricTabRef.current;
    
    console.log('fetchReadings - Initial tab state:', currentMetricTab, 'Sensor:', currentSelectedSensor);
    
    try {
      // Try to fetch readings for all sensors from API
      const readingsData: Record<string, Reading[]> = {};
      let apiSuccessful = true;
      
      // Fetch all sensors if we don't have any yet
      if (sensors.length === 0) {
        try {
          const sensorsResponse = await axios.get(`${API_URL}/readings/sensors`);
          console.log('Sensor API response:', sensorsResponse.data);
          
          // Update sensors list
          setSensors(sensorsResponse.data);
          
          // Get saved sensor from localStorage
          const savedSensor = localStorage.getItem('selectedSensor');
          
          if (currentSelectedSensor === null) {
            // If no sensor is selected, try to use the saved one or default to the first one
            if (savedSensor && sensorsResponse.data.includes(savedSensor)) {
              setSelectedSensor(savedSensor);
            } else if (sensorsResponse.data.length > 0) {
              setSelectedSensor(sensorsResponse.data[0]);
              localStorage.setItem('selectedSensor', sensorsResponse.data[0]);
            }
          } else if (!sensorsResponse.data.includes(currentSelectedSensor) && sensorsResponse.data.length > 0) {
            // If the currently selected sensor is not in the new list, select the first one
            setSelectedSensor(sensorsResponse.data[0]);
            localStorage.setItem('selectedSensor', sensorsResponse.data[0]);
          }
          // If currentSelectedSensor exists in the new list, don't change it
        } catch (error) {
          console.log('API error - Using dummy sensor data', SENSOR_IDS.length, 'sensors');
          
          // Ensure we're using the latest sensor IDs from dummyData.js
          setSensors(SENSOR_IDS);
          
          // Keep existing selection if possible, otherwise use first sensor
          if (selectedSensor === null && SENSOR_IDS.length > 0) {
            const newSensor = SENSOR_IDS[0];
            setSelectedSensor(newSensor);
            selectedSensorRef.current = newSensor;
          } else if (selectedSensor && SENSOR_IDS.includes(selectedSensor)) {
            // Make sure the ref is updated to match current sensor
            selectedSensorRef.current = selectedSensor;
          } else if (SENSOR_IDS.length > 0) {
            // If current selection is not in the new sensor list, use the first one
            const newSensor = SENSOR_IDS[0];
            setSelectedSensor(newSensor);
            selectedSensorRef.current = newSensor;
          }
          apiSuccessful = false;
        }
      }
      
      // If we have sensors, try to fetch their readings
      if (apiSuccessful) {
        const currentSensors = sensors.length > 0 ? sensors : SENSOR_IDS;
        
        for (const sensorId of currentSensors) {
          try {
            const response = await axios.get(`${API_URL}/readings?sensorId=${sensorId}`);
            readingsData[sensorId] = response.data;
          } catch (error) {
            apiSuccessful = false;
            break;
          }
        }
      }
      
      // Use dummy data if API failed or no readings found
      if (!apiSuccessful || Object.keys(readingsData).length === 0) {
        console.log('Using dummy reading data for', SENSOR_IDS.length, 'sensors');
        const dummyReadings = generateDummyReadings() as Record<string, Reading[]>;
        
        // Make sure sensors state is updated with the latest SENSOR_IDS
        if (JSON.stringify(sensors) !== JSON.stringify(SENSOR_IDS)) {
          setSensors(SENSOR_IDS);
        }
        
        // Only update readings if they've actually changed
        setReadings(prevReadings => {
          if (JSON.stringify(prevReadings) !== JSON.stringify(dummyReadings)) {
            return dummyReadings;
          }
          return prevReadings;
        });
        
        // Use dummy events if no real events exist
        if (events.length === 0) {
          setEvents(generateDummyEvents());
          setAlertCount(generateDummyEvents().length);
        }
      } else {
        console.log('Using API data readings:', Object.keys(readingsData).length, 'sensors');
        // Only update readings if they've actually changed
        setReadings(prevReadings => {
          if (JSON.stringify(prevReadings) !== JSON.stringify(readingsData)) {
            return readingsData;
          }
          return prevReadings;
        });
      }
      
      // Update alert count by checking for threshold breaches in the new readings
      let newAlertCount = 0;
      Object.values(readingsData).forEach(sensorReadings => {
        if (sensorReadings.length > 0) {
          const latestReading = sensorReadings[sensorReadings.length - 1];
          if (
            (latestReading.turbidity && latestReading.turbidity > 70) ||
            (latestReading.vibration && latestReading.vibration > 0.15) ||
            (latestReading.tankLevel && latestReading.tankLevel < 20)
          ) {
            newAlertCount++;
          }
        }
      });
      
      if (newAlertCount > 0) {
        setAlertCount(newAlertCount);
      }
      
    } catch (error) {
      console.error('Error fetching readings:', error);
      
      // Fallback to dummy data
      const dummyReadings = generateDummyReadings() as Record<string, Reading[]>;
      
      // Make sure sensors state is updated with the latest SENSOR_IDS
      if (JSON.stringify(sensors) !== JSON.stringify(SENSOR_IDS)) {
        setSensors(SENSOR_IDS);
      }
      
      setReadings(dummyReadings);
      if (events.length === 0) {
        setEvents(generateDummyEvents());
      }
    } finally {
      // CRITICAL: Always restore the selected sensor and active tab that were saved at the beginning
      console.log('fetchReadings completed - Restoring tab state:', currentMetricTab, 'Sensor:', currentSelectedSensor);
      
      if (currentSelectedSensor && currentSelectedSensor !== selectedSensorRef.current) {
        setSelectedSensor(currentSelectedSensor);
        selectedSensorRef.current = currentSelectedSensor;
      }
      
      // Only restore the tab state if it actually changed during the fetch operation
      // or if it doesn't match what's currently in the ref
      if (currentMetricTab && activeMetricTabRef.current !== currentMetricTab) {
        console.log('Tab state changed during fetch, restoring to:', currentMetricTab);
        setActiveMetricTab(currentMetricTab);
      }
    }
  };

  return (
    <div className={`min-h-screen ${theme === 'dark' ? 'bg-gradient-to-br from-slate-900 via-blue-900/20 to-slate-800' : 'bg-gradient-to-br from-blue-50 to-indigo-50'} text-white p-4 md:p-6 transition-colors duration-300`}>
      <div className="max-w-7xl mx-auto">
        {/* Header with improved styling */}
        <header className="mb-8">
          <div className="flex flex-col md:flex-row justify-between items-start md:items-center">
            <div className="flex items-center">
              <div className="mr-3">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-10 h-10 text-blue-400">
                  <path d="M11.7 2.805a.75.75 0 01.6 0A60.65 60.65 0 0122.83 8.72a.75.75 0 01-.231 1.337 49.949 49.949 0 00-9.902 3.912l-.003.002-.34.18a.75.75 0 01-.707 0A50.009 50.009 0 007.5 12.174v-.224c0-.131.067-.248.172-.311a54.614 54.614 0 014.653-2.52.75.75 0 00-.65-1.352 56.129 56.129 0 00-4.78 2.589 1.858 1.858 0 00-.859 1.228 49.803 49.803 0 00-4.634-1.527.75.75 0 01-.231-1.337A60.653 60.653 0 0111.7 2.805z" />
                  <path d="M13.06 15.473a48.45 48.45 0 017.666-3.282c.134 1.414.22 2.843.255 4.285a.75.75 0 01-.46.71 47.878 47.878 0 00-8.105 4.342.75.75 0 01-.832 0 47.877 47.877 0 00-8.104-4.342.75.75 0 01-.461-.71c.035-1.442.121-2.87.255-4.286A48.4 48.4 0 016 13.18v1.27a1.5 1.5 0 00-.14 2.508c-.09.38-.222.753-.397 1.11.452.213.901.434 1.346.661a6.729 6.729 0 00.551-1.608 1.5 1.5 0 00.14-2.67v-.645a48.549 48.549 0 013.44 1.668 2.25 2.25 0 002.12 0z" />
                  <path d="M4.462 19.462c.42-.419.753-.89 1-1.394.453.213.902.434 1.347.661a6.743 6.743 0 01-1.286 1.794.75.75 0 11-1.06-1.06z" />
                </svg>
              </div>
              <div>
                <h1 className={`text-3xl font-bold ${theme === 'dark' ? 'text-white' : 'text-slate-800'}`}>Water Quality Monitor</h1>
                <div className={`flex items-center mt-1 ${theme === 'dark' ? 'text-slate-400' : 'text-slate-600'}`}>
                  <span className="text-sm">Last updated: {lastUpdated.toLocaleTimeString()}</span>
                  <span className="mx-2">•</span>
                  <span className="text-sm">{sensors.length} sensors online</span>
                  {alertCount > 0 && (
                    <>
                      <span className="mx-2">•</span>
                      <span className="flex items-center text-sm text-red-400">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 mr-1">
                          <path fillRule="evenodd" d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                        </svg>
                        {alertCount} alerts
                      </span>
                    </>
                  )}
                </div>
              </div>
            </div>
            
            <div className="flex items-center space-x-3 mt-4 md:mt-0">
              {/* Theme toggle */}
              <button 
                onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
                className={`p-2 rounded-full ${theme === 'dark' ? 'bg-slate-700 text-yellow-300' : 'bg-blue-100 text-slate-700'}`}
                aria-label="Toggle theme"
              >
                {theme === 'dark' ? (
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5">
                    <path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.06l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.06 1.06a.75.75 0 001.06 1.06l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.06 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.06a.75.75 0 10-1.06 1.06l1.06 1.06z" />
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5">
                    <path fillRule="evenodd" d="M7.455 2.004a.75.75 0 01.26.77 7 7 0 009.958 7.967.75.75 0 011.067.853A8.5 8.5 0 116.647 1.921a.75.75 0 01.808.083z" clipRule="evenodd" />
                  </svg>
                )}
              </button>
              
              {/* Wallet connection button */}
              {!isWalletConnected ? (
                <button
                  onClick={connectWallet}
                  className={`px-4 py-2 rounded-lg font-medium flex items-center ${
                    theme === 'dark' 
                      ? 'bg-indigo-600 hover:bg-indigo-700 text-white' 
                      : 'bg-indigo-500 hover:bg-indigo-600 text-white'
                  }`}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                  </svg>
                  Connect Wallet
                </button>
              ) : (
                <div className={`flex items-center px-4 py-2 rounded-lg ${theme === 'dark' ? 'bg-green-900/30 text-green-400' : 'bg-green-100 text-green-700'}`}>
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  Wallet Connected
                </div>
              )}
            </div>
          </div>
        </header>
        
        {isLoading ? (
          <div className="flex items-center justify-center h-96">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400"></div>
          </div>
        ) : (
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Main content area - 2/3 width on large screens */}
            <div className="lg:col-span-2 space-y-6">
              {/* Sensor Map with improved height */}
              <GlassCard className={`${theme === 'dark' ? '' : 'bg-white/80 text-slate-800 border border-slate-200'}`}>
                <div className="h-[380px]">
                  <SensorMap
                    sensors={sensors}
                    readings={readings}
                    selectedSensor={selectedSensor}
                    onSensorSelect={handleSensorSelect}
                  />
                </div>
              </GlassCard>
              
              {/* Metrics Chart */}
              <GlassCard className={`${theme === 'dark' ? '' : 'bg-white/80 text-slate-800 border border-slate-200'}`}>
                <div className="h-[300px]">
                  {/* Don't use a key at all to prevent remounting */}
                  <MetricsChart 
                    selectedSensor={selectedSensor}
                    readings={readings}
                    activeMetricTab={activeMetricTab}
                    setActiveMetricTab={setActiveMetricTab}
                  />
                </div>
              </GlassCard>
            </div>
            
            {/* Sidebar - 1/3 width on large screens */}
            <div className="space-y-6">
              {/* Sensor Details */}
              <GlassCard className={`${theme === 'dark' ? '' : 'bg-white/80 text-slate-800 border border-slate-200'}`}>
                <div className="h-[380px]">
                  <SensorDetails
                    selectedSensor={selectedSensor}
                    sensors={sensors}
                    readings={readings}
                    onSensorSelect={handleSensorSelect}
                  />
                </div>
              </GlassCard>
              
              {/* Blockchain Events */}
              <GlassCard className={`${theme === 'dark' ? '' : 'bg-white/80 text-slate-800 border border-slate-200'}`}>
                <div className="h-[300px] flex flex-col">
                  <h2 className="text-lg font-semibold mb-3">Blockchain Events</h2>
                  <div className="flex-1 overflow-hidden">
                    <Timeline events={events} />
                  </div>
                </div>
              </GlassCard>
            </div>
          </div>
        )}
        
        <footer className={`mt-8 text-center text-sm pb-4 ${theme === 'dark' ? 'text-slate-500' : 'text-slate-600'}`}>
          <p>Water Quality Monitoring System — {new Date().getFullYear()}</p>
          <p className="mt-1 text-xs">Secure monitoring with blockchain verification</p>
        </footer>
      </div>
    </div>
  );
};

export default Dashboard;

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/pages/garbage-management.tsx ---
import React, { useState, useEffect } from 'react';
import { BIN_IDS, GARBAGE_BINS, BLOCKCHAIN_EVENTS } from '../utils/garbageDummyData';
import GlassCard from '../components/GlassCard';
import UserOnboarding from '../components/garbage/UserOnboarding';
import BagAssignment from '../components/garbage/BagAssignment';
import BinScanner from '../components/garbage/BinScanner';
import PointsDashboard from '../components/garbage/PointsDashboard';

const GarbageManagement = () => {
  const [activeTab, setActiveTab] = useState<string>('userOnboarding');
  const [selectedBin, setSelectedBin] = useState<string | null>(null);
  const [binType, setBinType] = useState<string | null>(null);
  const [filteredEvents, setFilteredEvents] = useState<any[]>([]);
  const [selectedUser, setSelectedUser] = useState<string>('all');
  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
  
  // Initialize with first bin on mount
  useEffect(() => {
    if (BIN_IDS.length > 0) {
      setSelectedBin(BIN_IDS[0]);
      
      // Get bin type from GARBAGE_BINS
      const binInfo = GARBAGE_BINS.find(bin => bin.id === BIN_IDS[0]);
      if (binInfo) {
        setBinType(binInfo.binType);
      }
    }
    
    // Initialize blockchain events
    setFilteredEvents(BLOCKCHAIN_EVENTS);
  }, []);
  
  // Filter events when filters change
  useEffect(() => {
    let filtered = [...BLOCKCHAIN_EVENTS];
    
    // Filter by user
    if (selectedUser !== 'all') {
      filtered = filtered.filter(event => event.userId === selectedUser);
    }
    
    // Filter by event type
    if (eventTypeFilter !== 'all') {
      filtered = filtered.filter(event => event.eventType === eventTypeFilter);
    }
    
    setFilteredEvents(filtered);
  }, [selectedUser, eventTypeFilter]);
  
  // Handle bin selection change
  const handleBinChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const binId = e.target.value;
    setSelectedBin(binId);
    
    // Update bin type
    const binInfo = GARBAGE_BINS.find(bin => bin.id === binId);
    if (binInfo) {
      setBinType(binInfo.binType);
    }
  };
  
  const renderTabContent = () => {
    switch (activeTab) {
      case 'userOnboarding':
        return <UserOnboarding />;
      case 'bagAssignment':
        return <BagAssignment />;
      case 'binScanner':
        return (
          <div className="space-y-6">
            <GlassCard>
              <div className="mb-4">
                <h2 className="text-xl font-semibold mb-4">Selected Bin for Manual Scanning</h2>
                <div className="flex gap-4">
                  <div className="flex-1">
                    <label htmlFor="binSelect" className="block text-sm font-medium text-gray-300 mb-1">
                      Bin ID
                    </label>
                    <select
                      id="binSelect"
                      value={selectedBin || ''}
                      onChange={handleBinChange}
                      className="w-full bg-slate-800 border border-slate-700 rounded-md p-2 text-white"
                    >
                      {BIN_IDS.map(binId => (
                        <option key={binId} value={binId}>
                          {binId}
                        </option>
                      ))}
                    </select>
                  </div>
                  
                  <div className="flex-1">
                    <label className="block text-sm font-medium text-gray-300 mb-1">
                      Bin Type
                    </label>
                    <div className="bg-slate-800 border border-slate-700 rounded-md p-2 text-white capitalize">
                      {binType?.replace('-', ' ') || 'Unknown'}
                    </div>
                  </div>
                  
                  <div className="flex-1">
                    <label className="block text-sm font-medium text-gray-300 mb-1">
                      Status
                    </label>
                    <div className="bg-green-500/20 border border-green-500/30 text-green-300 rounded-md p-2">
                      Online
                    </div>
                  </div>
                </div>
              </div>
            </GlassCard>
            
            <BinScanner 
              selectedBin={selectedBin} 
              binType={binType}
            />
          </div>
        );
      case 'pointsDashboard':
        return <PointsDashboard />;
      case 'blockchainTimeline':
        return (
          <div className="space-y-6">
            <GlassCard>
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold">Blockchain Registry Timeline</h2>
                
                <div className="flex gap-2">
                  <select
                    value={selectedUser}
                    onChange={(e) => setSelectedUser(e.target.value)}
                    className="bg-slate-800 border border-slate-700 rounded-md p-1 text-sm text-white"
                  >
                    <option value="all">All Users</option>
                    {Array.from(new Set(BLOCKCHAIN_EVENTS.map(event => event.userId)))
                      .filter(Boolean)
                      .map(userId => {
                        const userEvent = BLOCKCHAIN_EVENTS.find(e => e.userId === userId);
                        const userName = userEvent?.userId || 'Unknown';
                        return (
                          <option key={userId} value={userId}>{userName}</option>
                        );
                      })}
                  </select>
                  
                  <select
                    value={eventTypeFilter}
                    onChange={(e) => setEventTypeFilter(e.target.value)}
                    className="bg-slate-800 border border-slate-700 rounded-md p-1 text-sm text-white"
                  >
                    <option value="all">All Events</option>
                    <option value="user-registration">User Registration</option>
                    <option value="bag-issuance">Bag Issuance</option>
                    <option value="disposal">Disposal</option>
                    <option value="reward">Rewards</option>
                    <option value="fine">Fines</option>
                  </select>
                </div>
              </div>
              
              <div className="mt-4">
                <p className="text-gray-300 text-sm mb-4">
                  Viewing all blockchain events and registry entries in the waste management system. 
                  Each entry represents an immutable record on the blockchain.
                </p>
                
                <div className="space-y-3 max-h-[600px] overflow-y-auto pr-2">
                  {filteredEvents.length === 0 ? (
                    <div className="p-4 text-center text-gray-400">
                      No events to display
                    </div>
                  ) : (
                    filteredEvents.map(event => (
                      <div key={event.id} className="p-3 bg-slate-800 rounded-md">
                        <div className="flex">
                          <div className="mr-3 text-2xl">
                            {event.eventType === 'user-registration' && '👤'}
                            {event.eventType === 'bag-issuance' && '🛍️'}
                            {event.eventType === 'disposal' && '🗑️'}
                            {event.eventType === 'reward' && '🏆'}
                            {event.eventType === 'fine' && '💸'}
                          </div>
                          <div className="flex-1">
                            <div className="font-medium">
                              {event.eventType === 'user-registration' && `User registered: ${event.userId}`}
                              {event.eventType === 'bag-issuance' && `Bag issued: ${event.bagId} to ${event.userId}`}
                              {event.eventType === 'disposal' && `Waste disposal: ${event.correct ? 'Correct' : 'Incorrect'} by ${event.userId}`}
                              {event.eventType === 'reward' && `Reward issued: ${event.pointsAwarded} points to ${event.userId}`}
                              {event.eventType === 'fine' && `Fine issued: $${event.fineAmount} to ${event.userId}`}
                            </div>
                            <div className="text-xs text-gray-400">{new Date(event.timestamp).toLocaleString()}</div>
                            <div className="flex mt-1">
                              {event.eventType === 'disposal' && (
                                <span className={`text-xs px-2 py-0.5 rounded-full ${
                                  event.correct
                                    ? 'bg-green-500/20 text-green-300'
                                    : 'bg-red-500/20 text-red-300'
                                }`}>
                                  {event.correct ? 'Correct' : 'Incorrect'} Disposal
                                </span>
                              )}
                              {event.eventType === 'reward' && (
                                <span className="text-xs px-2 py-0.5 rounded-full bg-blue-500/20 text-blue-300">
                                  +{event.pointsAwarded} Points
                                </span>
                              )}
                              {event.eventType === 'fine' && (
                                <span className="text-xs px-2 py-0.5 rounded-full bg-red-500/20 text-red-300">
                                  ${event.fineAmount} Fine
                                </span>
                              )}
                            </div>
                          </div>
                          <div className="text-right">
                            <a 
                              href={`https://etherscan.io/tx/${event.txHash}`}
                              target="_blank"
                              rel="noopener noreferrer" 
                              className="text-xs text-blue-400 hover:underline"
                            >
                              View Transaction ↗
                            </a>
                          </div>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </GlassCard>
          </div>
        );
      default:
        return <UserOnboarding />;
    }
  };
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-green-900/20 to-slate-800 text-white">
      {/* Header */}
      <header className="bg-slate-900/80 backdrop-blur-sm p-4 border-b border-slate-800">
        <div className="container mx-auto flex justify-between items-center">
          <div className="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-7 h-7 text-green-400 mr-3">
              <path d="M3.375 3C2.339 3 1.5 3.84 1.5 4.875v.75c0 1.036.84 1.875 1.875 1.875h17.25c1.035 0 1.875-.84 1.875-1.875v-.75C22.5 3.839 21.66 3 20.625 3H3.375z" />
              <path fillRule="evenodd" d="M3.087 9l.54 9.176A3 3 0 006.62 21h10.757a3 3 0 002.995-2.824L20.913 9H3.087zm6.133 2.845a.75.75 0 011.06 0l1.72 1.72 1.72-1.72a.75.75 0 111.06 1.06l-1.72 1.72 1.72 1.72a.75.75 0 11-1.06 1.06L12 15.685l-1.72 1.72a.75.75 0 11-1.06-1.06l1.72-1.72-1.72-1.72a.75.75 0 010-1.06z" clipRule="evenodd" />
            </svg>
            <h1 className="text-xl font-bold text-white">Garbage Management System</h1>
          </div>
          
          <div>
            <a href="/test/garbage-dashboard" className="text-gray-400 hover:text-white transition-colors flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M7.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
              </svg>
              Garbage Dashboard
            </a>
          </div>
        </div>
      </header>
      
      {/* Main content */}
      <main className="container mx-auto px-4 py-8">
        {/* Tabs */}
        <div className="flex overflow-x-auto mb-8 border-b border-slate-700">
          <button
            className={`px-4 py-3 font-medium border-b-2 transition-colors whitespace-nowrap ${
              activeTab === 'userOnboarding' 
                ? 'border-green-400 text-green-400' 
                : 'border-transparent text-gray-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('userOnboarding')}
          >
            User Onboarding
          </button>
          
          <button
            className={`px-4 py-3 font-medium border-b-2 transition-colors whitespace-nowrap ${
              activeTab === 'bagAssignment' 
                ? 'border-green-400 text-green-400' 
                : 'border-transparent text-gray-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('bagAssignment')}
          >
            Bag Assignment
          </button>
          
          <button
            className={`px-4 py-3 font-medium border-b-2 transition-colors whitespace-nowrap ${
              activeTab === 'binScanner' 
                ? 'border-green-400 text-green-400' 
                : 'border-transparent text-gray-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('binScanner')}
          >
            Manual Bag Scanner
          </button>
          
          <button
            className={`px-4 py-3 font-medium border-b-2 transition-colors whitespace-nowrap ${
              activeTab === 'pointsDashboard' 
                ? 'border-green-400 text-green-400' 
                : 'border-transparent text-gray-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('pointsDashboard')}
          >
            Points Dashboard
          </button>
          
          <button
            className={`px-4 py-3 font-medium border-b-2 transition-colors whitespace-nowrap ${
              activeTab === 'blockchainTimeline' 
                ? 'border-green-400 text-green-400' 
                : 'border-transparent text-gray-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('blockchainTimeline')}
          >
            Blockchain Registry
          </button>
        </div>
        
        {/* Tab content */}
        {renderTabContent()}
      </main>
    </div>
  );
};

export default GarbageManagement; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/pages/_app.js ---
import '../styles/globals.css';
import { Roboto } from 'next/font/google';

const roboto = Roboto({
  weight: ['300', '400', '500', '700'],
  subsets: ['latin'],
  display: 'swap',
});

function MyApp({ Component, pageProps }) {
  return (
    <main className={roboto.className}>
      <Component {...pageProps} />
    </main>
  );
}

export default MyApp;


================================================================================

Directory: /home/ayes/water-quality-monitor/frontend/pages/test

--- FILE: /home/ayes/water-quality-monitor/frontend/pages/test/garbage-dashboard.tsx ---
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  PointElement, 
  LineElement, 
  Title, 
  Tooltip, 
  Legend,
} from 'chart.js';
import { ethers } from 'ethers';
import SensorMap from '../../components/SensorMap';
import MetricsChart from '../../components/MetricsChart';
import SensorDetails from '../../components/SensorDetails';
import GlassCard from '../../components/GlassCard';
import GarbageTimeline from '../../components/garbage/GarbageTimeline';
import { BIN_IDS, GARBAGE_BINS, BIN_NETWORK_CONNECTIONS, generateDummyReadings, generateDummyEvents } from '../../utils/garbageDummyData';

// Register ChartJS components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Add global declaration for window.ethereum
declare global {
  interface Window {
    ethereum: any;
  }
}

// Basic Reading type
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  fillLevel?: number;             // 0–100%
  doorOpen?: boolean;             // true if bin lid open
  lastCollectionTimestamp?: number;
  batteryLevel?: number;
  binType?: string;
  latitude?: number;
  longitude?: number;
  txHash?: string;
  [key: string]: any; // Allow for any other properties
};

// Event type for blockchain timeline
type BlockchainEvent = {
  id?: string;          // Added to match GarbageBlockchainEvent
  sensorId: string;
  value: number;
  timestamp: number;
  txHash: string;
  metricType?: string;
  eventType?: string;   // Added to match GarbageBlockchainEvent
  userId?: string;      // Added to match GarbageBlockchainEvent
  bagId?: string;       // Added to match GarbageBlockchainEvent
  correct?: boolean;    // Added to match GarbageBlockchainEvent
  pointsAwarded?: number; // Added to match GarbageBlockchainEvent
  fineAmount?: number;  // Added to match GarbageBlockchainEvent
};

// Mock contract settings
const CONTRACT_ADDRESS = "0x0000000000000000000000000000000000000000"; // Dummy address
const CONTRACT_ABI = [
  'event GarbageEvent(string indexed sensorId, uint256 timestamp, uint8 fillLevel, string eventType, bytes32 dataHash)',
];

const GarbageDashboard = () => {
  // Basic state management
  const [readings, setReadings] = useState<Record<string, Reading[]>>({});
  const [bins, setBins] = useState<string[]>([]);
  const [selectedBin, setSelectedBin] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [eventsMap, setEventsMap] = useState<Record<string, BlockchainEvent[]>>({});
  const [activeMetricTab, setActiveMetricTab] = useState<string>('primary');
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  
  // State for bin details view
  const [showModal, setShowModal] = useState<boolean>(false);
  const [viewingBinId, setViewingBinId] = useState<string | null>(null);
  
  // References to prevent state loss during re-renders
  const selectedBinRef = useRef<string | null>(null);
  const activeMetricTabRef = useRef<string>('primary');
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);
  
  // Create a stable callback for bin selection
  const handleBinSelect = useCallback((binId: string) => {
    console.log('User selected bin:', binId);
    setSelectedBin(binId);
    selectedBinRef.current = binId;
  }, []);
  
  // Handle view details click
  const handleViewDetails = useCallback((binId: string) => {
    console.log('View details for bin:', binId);
    setViewingBinId(binId);
    setShowModal(true);
  }, []);
  
  // Close modal
  const handleCloseModal = useCallback(() => {
    setShowModal(false);
  }, []);

  // Keep the ref in sync with state
  useEffect(() => {
    activeMetricTabRef.current = activeMetricTab;
  }, [activeMetricTab]);

  // Connect to Ethereum provider
  const connectWallet = async () => {
    if (window.ethereum) {
      try {
        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Create provider
        const provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(provider);
        
        // Create contract instance
        if (CONTRACT_ADDRESS) {
          const contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            provider
          );
          setContract(contract);
          
          // Listen for events
          contract.on('GarbageEvent', (sensorId, timestamp, fillLevel, eventType, dataHash, event) => {
            const newEvent: BlockchainEvent = {
              sensorId: sensorId,
              value: Number(fillLevel),
              timestamp: Number(timestamp),
              txHash: event.transactionHash,
              metricType: eventType
            };
            
            setEventsMap(prev => {
              const list = prev[sensorId] || [];
              return {
                ...prev,
                [sensorId]: [newEvent, ...list]
              };
            });
          });
        }
        
        setIsWalletConnected(true);
      } catch (error) {
        console.error('Error connecting to wallet:', error);
      }
    } else {
      console.log('MetaMask not installed. Using dummy events instead.');
    }
  };

  // Fetch data (using dummy data for the test dashboard)
  const fetchReadings = async () => {
    try {
      // For testing, use dummy data
      const dummyReadings = generateDummyReadings() as Record<string, Reading[]>;
      
      setReadings(prevReadings => {
        // Only update if there's a difference to avoid unnecessary rerenders
        if (JSON.stringify(prevReadings) !== JSON.stringify(dummyReadings)) {
          return dummyReadings;
        }
        return prevReadings;
      });
      
      // Generate new dummy events more frequently (50% chance instead of 30%)
      if (Math.random() > 0.5 || Object.keys(eventsMap).length === 0) {
        const newEvents = generateDummyEvents();
        
        // Now we need to organize new events by sensorId
        setEventsMap(prevEventsMap => {
          const updatedEventsMap = { ...prevEventsMap };
          
          // Group events by sensorId
          newEvents.forEach(event => {
            const sensorId = event.sensorId;
            if (!updatedEventsMap[sensorId]) {
              updatedEventsMap[sensorId] = [];
            }
            
            // Check if this event already exists for this sensor
            const exists = updatedEventsMap[sensorId].some(e => e.txHash === event.txHash);
            if (!exists) {
              // Add new event to this sensor's list
              // Convert to new event format while adding
              const adaptedEvent: BlockchainEvent = {
                ...event,
                id: `event-${event.timestamp}-${Math.random().toString(36).substring(2, 9)}`,
                eventType: event.metricType || 'measurement',
                // Map common metricTypes to eventTypes
                ...(event.metricType === 'correctDisposal' && { 
                  eventType: 'disposal',
                  correct: true 
                }),
                ...(event.metricType === 'misuseAlert' && { 
                  eventType: 'disposal',
                  correct: false 
                }),
                ...(event.metricType === 'rewardIssued' && { 
                  eventType: 'reward',
                  pointsAwarded: event.points || Math.floor(Math.random() * 5) + 1
                }),
                ...(event.metricType === 'fineIssued' && { 
                  eventType: 'fine',
                  fineAmount: event.amount || (Math.floor(Math.random() * 4) + 1) * 5
                }),
                ...(event.metricType === 'fillLevelAlert' && { 
                  eventType: 'fillLevelAlert' 
                }),
                ...(event.metricType === 'collectionConfirmed' && { 
                  eventType: 'collectionConfirmed' 
                }),
                ...(event.metricType === 'doorOpenAlert' && { 
                  eventType: 'doorOpenAlert' 
                }),
                ...(event.metricType === 'batteryLow' && { 
                  eventType: 'batteryLow' 
                }),
                ...(event.metricType === 'bagIssued' && { 
                  eventType: 'bag-issuance'
                }),
              };
              
              updatedEventsMap[sensorId] = [adaptedEvent, ...updatedEventsMap[sensorId]];
            }
          });
          
          // For each sensor, sort events by timestamp (newest first)
          Object.keys(updatedEventsMap).forEach(sensorId => {
            updatedEventsMap[sensorId].sort((a, b) => b.timestamp - a.timestamp);
            
            // Optional: limit each sensor's events (uncomment if you want to cap per sensor)
            // updatedEventsMap[sensorId] = updatedEventsMap[sensorId].slice(0, 100);
          });
          
          return updatedEventsMap;
        });
      }
      
      // Update last updated timestamp
      setLastUpdated(new Date());
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  // Initial data fetch
  useEffect(() => {
    console.log('Initial data fetch');
    setIsLoading(true);
    
    // Simple fetch function for now
    const fetchInitialData = async () => {
      try {
        await fetchReadings();
        setBins(BIN_IDS);
        
        // Select first bin by default
        if (BIN_IDS.length > 0) {
          setSelectedBin(BIN_IDS[0]);
          selectedBinRef.current = BIN_IDS[0];
        }
        
        // Try to connect to wallet
        connectWallet();
      } catch (error) {
        console.error('Error fetching initial data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchInitialData();
    
    // Set up polling for new data every 5 seconds
    pollingInterval.current = setInterval(() => {
      fetchReadings();
    }, 5000);
    
    // Cleanup on unmount
    return () => {
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
      
      // Remove contract event listeners if any
      if (contract) {
        contract.removeAllListeners();
      }
    };
  }, []);

  // Update events when viewing bin changes
  useEffect(() => {
    // Always fetch readings when the modal is closed to ensure we keep accumulating events
    if (!viewingBinId) {
      fetchReadings();
    }
  }, [viewingBinId]);

  // Get the selected bin info
  const getSelectedBinPosition = () => {
    if (!selectedBin) return null;
    const binInfo = GARBAGE_BINS.find(s => s.id === selectedBin);
    return binInfo ? { lat: binInfo.lat, lng: binInfo.lng } : null;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-green-900/20 to-slate-800 text-white">
      {/* Main content with map */}
      <div className="relative">
        {/* Full-screen map container - absolute but lower z-index */}
        <div className="absolute inset-0 z-0">
          {isLoading ? (
            <div className="flex items-center justify-center h-full">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-400"></div>
            </div>
          ) : (
            <div className="h-full pt-16">
              <SensorMap
                sensors={bins}
                readings={readings}
                selectedSensor={selectedBin}
                onSensorSelect={handleBinSelect}
              />
            </div>
          )}
        </div>
        
        {/* Navbar */}
        <div className="relative z-10 bg-slate-900/80 backdrop-blur-sm p-4 flex justify-between items-center">
          <div className="flex items-center">
            <div className="mr-3">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-7 h-7 text-green-400">
                <path d="M3.375 3C2.339 3 1.5 3.84 1.5 4.875v.75c0 1.036.84 1.875 1.875 1.875h17.25c1.035 0 1.875-.84 1.875-1.875v-.75C22.5 3.839 21.66 3 20.625 3H3.375z" />
                <path fillRule="evenodd" d="M3.087 9l.54 9.176A3 3 0 006.62 21h10.757a3 3 0 002.995-2.824L20.913 9H3.087zm6.133 2.845a.75.75 0 011.06 0l1.72 1.72 1.72-1.72a.75.75 0 111.06 1.06l-1.72 1.72 1.72 1.72a.75.75 0 11-1.06 1.06L12 15.685l-1.72 1.72a.75.75 0 11-1.06-1.06l1.72-1.72-1.72-1.72a.75.75 0 010-1.06z" clipRule="evenodd" />
              </svg>
            </div>
            <h1 className="text-xl font-bold text-white">Garbage Collection Monitor</h1>
            <div className="ml-4 text-sm text-slate-400">
              Last updated: {lastUpdated.toLocaleTimeString()}
            </div>
          </div>
          
          <div className="flex items-center space-x-3">
            {/* Navigation to Garbage Management */}
            <a 
              href="/garbage-management" 
              className="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg shadow-lg flex items-center"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
              Garbage Management
            </a>
            
            {/* Wallet connection button */}
            {!isWalletConnected ? (
              <button
                onClick={connectWallet}
                className="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg shadow-lg flex items-center"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                </svg>
                Connect Wallet
              </button>
            ) : (
              <div className="flex items-center px-4 py-2 rounded-lg bg-green-900/30 text-green-400">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
                Wallet Connected
              </div>
            )}
            
            {/* View Details Button - appears when a bin is selected */}
            {selectedBin && (
              <button
                onClick={() => handleViewDetails(selectedBin)}
                className="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-lg shadow-lg flex items-center"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                  <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                </svg>
                View Details
              </button>
            )}
          </div>
        </div>
        
        {/* Invisible full-height container to ensure content takes up the full height */}
        <div className="h-screen w-full pointer-events-none" aria-hidden="true"></div>
      </div>
      
      {/* Modal with bin details, metrics and timeline */}
      {showModal && viewingBinId && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
          <div className="bg-slate-800 rounded-xl shadow-xl w-full max-w-5xl max-h-[90vh] overflow-hidden">
            {/* Modal header */}
            <div className="p-6 border-b border-slate-700 flex justify-between items-center">
              <h2 className="text-xl font-semibold">Bin Details: {viewingBinId}</h2>
              <button 
                onClick={handleCloseModal}
                className="p-2 hover:bg-slate-700 rounded-full text-slate-400 hover:text-white"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            
            {/* Modal content */}
            <div className="p-6 overflow-y-auto max-h-[calc(90vh-130px)]">
              <div className="flex flex-col">
                {/* First row - Metrics chart only with larger height */}
                <div className="mb-0">
                  <GlassCard>
                    <div className="h-[450px]">
                      <MetricsChart 
                        selectedSensor={viewingBinId}
                        readings={readings}
                        activeMetricTab={activeMetricTab}
                        setActiveMetricTab={setActiveMetricTab}
                      />
                    </div>
                  </GlassCard>
                </div>
                
                {/* Second row - Bin details and Blockchain events side by side */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                  {/* Left column - Bin details */}
                  <div className="h-80">
                    <GlassCard className="h-full">
                      <div className="h-full overflow-y-auto">
                        <SensorDetails
                          selectedSensor={viewingBinId}
                          sensors={bins}
                          readings={readings}
                          onSensorSelect={handleBinSelect}
                        />
                      </div>
                    </GlassCard>
                  </div>
                  
                  {/* Right column - Blockchain events */}
                  <div className="h-80">
                    <GlassCard className="h-full">
                      <div className="flex flex-col h-full">
                        <h2 className="text-lg font-semibold mb-3">
                          Blockchain Events
                          <span className="ml-2 bg-green-500/20 text-green-300 text-sm py-0.5 px-2 rounded-full">
                            {(eventsMap[viewingBinId] || []).length}
                          </span>
                        </h2>
                        <div className="flex-1 min-h-0">
                          <GarbageTimeline events={
                            // Convert the events to the format expected by GarbageTimeline
                            (eventsMap[viewingBinId] || []).map(event => ({
                              id: event.id || `event-${event.timestamp}-${Math.random().toString(36).substring(2, 9)}`,
                              timestamp: event.timestamp,
                              txHash: event.txHash,
                              eventType: event.eventType || event.metricType || 'measurement',
                              sensorId: event.sensorId,
                              value: event.value,
                              userId: event.userId,
                              bagId: event.bagId,
                              correct: event.correct,
                              pointsAwarded: event.pointsAwarded,
                              fineAmount: event.fineAmount
                            }))
                          } />
                        </div>
                      </div>
                    </GlassCard>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default GarbageDashboard; 

================================================================================


--- FILE: /home/ayes/water-quality-monitor/frontend/pages/test/dashboard.tsx ---
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  PointElement, 
  LineElement, 
  Title, 
  Tooltip, 
  Legend,
} from 'chart.js';
import { ethers } from 'ethers';
import SensorMap from '../../components/SensorMap';
import MetricsChart from '../../components/MetricsChart';
import SensorDetails from '../../components/SensorDetails';
import Timeline from '../../components/Timeline';
import GlassCard from '../../components/GlassCard';
import { SENSOR_IDS, generateDummyReadings, PANAMA_CITY_SENSORS, generateDummyEvents } from '../../utils/dummyData';

// Register ChartJS components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Add global declaration for window.ethereum
declare global {
  interface Window {
    ethereum: any;
  }
}

// Basic Reading type
type Reading = {
  sensorId: string;
  timestamp: number;
  sensorType: string;
  [key: string]: any; // Allow for any other properties
};

// Event type for blockchain timeline
type BlockchainEvent = {
  sensorId: string;
  value: number;
  timestamp: number;
  txHash: string;
  metricType?: string;
};

// Mock contract settings
const CONTRACT_ADDRESS = "0x0000000000000000000000000000000000000000"; // Dummy address
const CONTRACT_ABI = [
  'event ReadingRecorded(bytes32 indexed sensorId, uint256 value, uint256 ts)',
];

const TestDashboard = () => {
  // Basic state management
  const [readings, setReadings] = useState<Record<string, Reading[]>>({});
  const [sensors, setSensors] = useState<string[]>([]);
  const [selectedSensor, setSelectedSensor] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [eventsMap, setEventsMap] = useState<Record<string, BlockchainEvent[]>>({});
  const [activeMetricTab, setActiveMetricTab] = useState<string>('primary');
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  
  // State for sensor details view
  const [showModal, setShowModal] = useState<boolean>(false);
  const [viewingSensorId, setViewingSensorId] = useState<string | null>(null);
  
  // References to prevent state loss during re-renders
  const selectedSensorRef = useRef<string | null>(null);
  const activeMetricTabRef = useRef<string>('primary');
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);
  
  // Create a stable callback for sensor selection
  const handleSensorSelect = useCallback((sensorId: string) => {
    console.log('User selected sensor:', sensorId);
    setSelectedSensor(sensorId);
    selectedSensorRef.current = sensorId;
  }, []);
  
  // Handle view details click
  const handleViewDetails = useCallback((sensorId: string) => {
    console.log('View details for sensor:', sensorId);
    setViewingSensorId(sensorId);
    setShowModal(true);
  }, []);
  
  // Close modal
  const handleCloseModal = useCallback(() => {
    setShowModal(false);
  }, []);

  // Keep the ref in sync with state
  useEffect(() => {
    activeMetricTabRef.current = activeMetricTab;
  }, [activeMetricTab]);

  // Connect to Ethereum provider
  const connectWallet = async () => {
    if (window.ethereum) {
      try {
        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Create provider
        const provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(provider);
        
        // Create contract instance
        if (CONTRACT_ADDRESS) {
          const contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            provider
          );
          setContract(contract);
          
          // Listen for events
          contract.on('ReadingRecorded', (sensorId, value, ts, event) => {
            const decodedSensorId = ethers.decodeBytes32String(sensorId);
            const newEvent: BlockchainEvent = {
              sensorId: decodedSensorId,
              value: Number(value),
              timestamp: Number(ts),
              txHash: event.transactionHash,
            };
            
            setEventsMap(prev => {
              const list = prev[decodedSensorId] || [];
              return {
                ...prev,
                [decodedSensorId]: [newEvent, ...list]
              };
            });
          });
        }
        
        setIsWalletConnected(true);
      } catch (error) {
        console.error('Error connecting to wallet:', error);
      }
    } else {
      console.log('MetaMask not installed. Using dummy events instead.');
    }
  };

  // Fetch data (using dummy data for the test dashboard)
  const fetchReadings = async () => {
    try {
      // For testing, use dummy data
      const dummyReadings = generateDummyReadings() as Record<string, Reading[]>;
      
      setReadings(prevReadings => {
        // Only update if there's a difference to avoid unnecessary rerenders
        if (JSON.stringify(prevReadings) !== JSON.stringify(dummyReadings)) {
          return dummyReadings;
        }
        return prevReadings;
      });
      
      // Generate new dummy events more frequently (50% chance instead of 30%)
      if (Math.random() > 0.5 || Object.keys(eventsMap).length === 0) {
        const newEvents = generateDummyEvents();
        
        // Now we need to organize new events by sensorId
        setEventsMap(prevEventsMap => {
          const updatedEventsMap = { ...prevEventsMap };
          
          // Group events by sensorId
          newEvents.forEach(event => {
            const sensorId = event.sensorId;
            if (!updatedEventsMap[sensorId]) {
              updatedEventsMap[sensorId] = [];
            }
            
            // Check if this event already exists for this sensor
            const exists = updatedEventsMap[sensorId].some(e => e.txHash === event.txHash);
            if (!exists) {
              // Add new event to this sensor's list
              updatedEventsMap[sensorId] = [event, ...updatedEventsMap[sensorId]];
            }
          });
          
          // For each sensor, sort events by timestamp (newest first)
          Object.keys(updatedEventsMap).forEach(sensorId => {
            updatedEventsMap[sensorId].sort((a, b) => b.timestamp - a.timestamp);
            
            // Optional: limit each sensor's events (uncomment if you want to cap per sensor)
            // updatedEventsMap[sensorId] = updatedEventsMap[sensorId].slice(0, 100);
          });
          
          return updatedEventsMap;
        });
      }
      
      // Update last updated timestamp
      setLastUpdated(new Date());
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  // Initial data fetch
  useEffect(() => {
    console.log('Initial data fetch');
    setIsLoading(true);
    
    // Simple fetch function for now
    const fetchInitialData = async () => {
      try {
        await fetchReadings();
        setSensors(SENSOR_IDS);
        
        // Select first sensor by default
        if (SENSOR_IDS.length > 0) {
          setSelectedSensor(SENSOR_IDS[0]);
          selectedSensorRef.current = SENSOR_IDS[0];
        }
        
        // Try to connect to wallet
        connectWallet();
      } catch (error) {
        console.error('Error fetching initial data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchInitialData();
    
    // Set up polling for new data every 5 seconds
    pollingInterval.current = setInterval(() => {
      fetchReadings();
    }, 5000);
    
    // Cleanup on unmount
    return () => {
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
      
      // Remove contract event listeners if any
      if (contract) {
        contract.removeAllListeners();
      }
    };
  }, []);

  // Update events when viewing sensor changes
  useEffect(() => {
    // Always fetch readings when the modal is closed to ensure we keep accumulating events
    if (!viewingSensorId) {
      fetchReadings();
    }
  }, [viewingSensorId]);

  // Get the selected sensor info
  const getSelectedSensorPosition = () => {
    if (!selectedSensor) return null;
    const sensorInfo = PANAMA_CITY_SENSORS.find(s => s.id === selectedSensor);
    return sensorInfo ? { lat: sensorInfo.lat, lng: sensorInfo.lng } : null;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900/20 to-slate-800 text-white">
      {/* Main content with map */}
      <div className="relative">
        {/* Full-screen map container - absolute but lower z-index */}
        <div className="absolute inset-0 z-0">
          {isLoading ? (
            <div className="flex items-center justify-center h-full">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400"></div>
            </div>
          ) : (
            <div className="h-full pt-16">
              <SensorMap
                sensors={sensors}
                readings={readings}
                selectedSensor={selectedSensor}
                onSensorSelect={handleSensorSelect}
              />
            </div>
          )}
        </div>
        
        {/* Navbar */}
        <div className="relative z-10 bg-slate-900/80 backdrop-blur-sm p-4 flex justify-between items-center">
          <div className="flex items-center">
            <div className="mr-3">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-7 h-7 text-blue-400">
                <path d="M11.7 2.805a.75.75 0 01.6 0A60.65 60.65 0 0122.83 8.72a.75.75 0 01-.231 1.337 49.949 49.949 0 00-9.902 3.912l-.003.002-.34.18a.75.75 0 01-.707 0A50.009 50.009 0 007.5 12.174v-.224c0-.131.067-.248.172-.311a54.614 54.614 0 014.653-2.52.75.75 0 00-.65-1.352 56.129 56.129 0 00-4.78 2.589 1.858 1.858 0 00-.859 1.228 49.803 49.803 0 00-4.634-1.527.75.75 0 01-.231-1.337A60.653 60.653 0 0111.7 2.805z" />
                <path d="M13.06 15.473a48.45 48.45 0f 017.666-3.282c.134 1.414.22 2.843.255 4.285a.75.75 0 01-.46.71 47.878 47.878 0 00-8.105 4.342.75.75 0 01-.832 0 47.877 47.877 0 00-8.104-4.342.75.75 0 01-.461-.71c.035-1.442.121-2.87.255-4.286A48.4 48.4 0 016 13.18v1.27a1.5 1.5 0 00-.14 2.508c-.09.38-.222.753-.397 1.11.452.213.901.434 1.346.661a6.729 6.729 0 00.551-1.608 1.5 1.5 0 00.14-2.67v-.645a48.549 48.549 0 013.44 1.668 2.25 2.25 0 002.12 0z" />
                <path d="M4.462 19.462c.42-.419.753-.89 1-1.394.453.213.902.434 1.347.661a6.743 6.743 0 01-1.286 1.794.75.75 0 11-1.06-1.06z" />
              </svg>
            </div>
            <h1 className="text-xl font-bold text-white">Water Quality Monitor</h1>
            <div className="ml-4 text-sm text-slate-400">
              Last updated: {lastUpdated.toLocaleTimeString()}
            </div>
          </div>
          
          <div className="flex items-center space-x-3">
            {/* Wallet connection button */}
            {!isWalletConnected ? (
              <button
                onClick={connectWallet}
                className="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg shadow-lg flex items-center"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                </svg>
                Connect Wallet
              </button>
            ) : (
              <div className="flex items-center px-4 py-2 rounded-lg bg-green-900/30 text-green-400">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
                Wallet Connected
              </div>
            )}
            
            {/* View Details Button - appears when a sensor is selected */}
            {selectedSensor && (
              <button
                onClick={() => handleViewDetails(selectedSensor)}
                className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg shadow-lg flex items-center"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                  <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                </svg>
                View Details
              </button>
            )}
          </div>
        </div>
        
        {/* Invisible full-height container to ensure content takes up the full height */}
        <div className="h-screen w-full pointer-events-none" aria-hidden="true"></div>
      </div>
      
      {/* Modal with sensor details, metrics and timeline */}
      {showModal && viewingSensorId && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
          <div className="bg-slate-800 rounded-xl shadow-xl w-full max-w-5xl max-h-[90vh] overflow-hidden">
            {/* Modal header */}
            <div className="p-6 border-b border-slate-700 flex justify-between items-center">
              <h2 className="text-xl font-semibold">Sensor Details: {viewingSensorId}</h2>
              <button 
                onClick={handleCloseModal}
                className="p-2 hover:bg-slate-700 rounded-full text-slate-400 hover:text-white"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            
            {/* Modal content */}
            <div className="p-6 overflow-y-auto max-h-[calc(90vh-130px)]">
              <div className="flex flex-col">
                {/* First row - Metrics chart only with larger height */}
                <div className="mb-0">
                  <GlassCard>
                    <div className="h-[450px]">
                      <MetricsChart 
                        selectedSensor={viewingSensorId}
                        readings={readings}
                        activeMetricTab={activeMetricTab}
                        setActiveMetricTab={setActiveMetricTab}
                      />
                    </div>
                  </GlassCard>
                </div>
                
                {/* Second row - Sensor details and Blockchain events side by side */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                  {/* Left column - Sensor details */}
                  <div className="h-80">
                    <GlassCard>
                      <div className="h-full overflow-y-auto">
                        <SensorDetails
                          selectedSensor={viewingSensorId}
                          sensors={sensors}
                          readings={readings}
                          onSensorSelect={handleSensorSelect}
                        />
                      </div>
                    </GlassCard>
                  </div>
                  
                  {/* Right column - Blockchain events */}
                  <div className="h-80">
                    <GlassCard>
                      <div className="h-full flex flex-col">
                        <h2 className="text-lg font-semibold mb-3">
                          Blockchain Events
                          <span className="ml-2 bg-blue-500/20 text-blue-300 text-sm py-0.5 px-2 rounded-full">
                            {(eventsMap[viewingSensorId] || []).length}
                          </span>
                        </h2>
                        <div className="flex-1 overflow-hidden">
                          <Timeline events={eventsMap[viewingSensorId] || []} />
                        </div>
                      </div>
                    </GlassCard>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default TestDashboard;

================================================================================

End of content listing
